[[Archivo:Sorting quicksort anim.gif|right|280px|thumb|Quicksort en acción sobre una lista de números aleatorios. Las líneas horizontales son valores pivote.]]En computación y matemáticas un algoritmo de ordenamiento es un algoritmo que pone elementos de una lista o un vector en una secuencia dada por una relación de orden, es decir, el resultado de salida ha de ser una permutación &mdash;o reordenamiento&mdash; de la entrada que satisfaga la relación de orden dada. Las relaciones de orden más usadas son el orden numérico y el orden lexicográfico. Ordenamientos eficientes son importantes para optimizar el uso de otros algoritmos (como los de búsqueda y fusión) que requieren listas ordenadas para una ejecución rápida. También es útil para poner datos en forma canónica y para generar resultados legibles por humanos.Desde los comienzos de la computación, el problema del ordenamiento ha atraído gran cantidad de investigación, tal vez debido a la complejidad de resolverlo eficientemente a pesar de su planteamiento simple y familiar. Por ejemplo, BubbleSort fue analizado desde 1956.Bubble Sort: An archaeological algorithm analysis. Owen Astrachan Aunque muchos puedan considerarlo un problema resuelto, nuevos y útiles algoritmos de ordenamiento se siguen inventado hasta el día de hoy (por ejemplo, el ordenamiento de biblioteca se publicó por primera vez en el 2004). Los algoritmos de ordenamiento son comunes en las clases introductorias a la computación, donde la abundancia de algoritmos para el problema proporciona una gentil introducción a la variedad de conceptos núcleo de los algoritmos, como notación de O mayúscula, algoritmos divide y vencerás, estructuras de datos, análisis de los casos peor, mejor, y promedio, y límites inferiores.ClasificaciónLos algoritmos de ordenamiento se pueden clasificar de las siguientes maneras:La más común es clasificar según el lugar donde se realice la ordenaciónAlgoritmos de ordenamiento interno: en la memoria del ordenador.Algoritmos de ordenamiento externo: en un lugar externo como un disco duro.Por el tiempo que tardan en realizar la ordenación, dadas entradas ya ordenadas o inversamente ordenadas:Algoritmos de ordenación natural: Tarda lo mínimo posible cuando la entrada está ordenada.Algoritmos de ordenación no natural: Tarda lo mínimo posible cuando la entrada está inversamente ordenada.Por estabilidad: un ordenamiento estable mantiene el orden relativo que tenían originalmente los elementos con claves iguales. Por ejemplo, si una lista ordenada por fecha se reordena en orden alfabético con un algoritmo estable, todos los elementos cuya clave alfabética sea la misma quedarán en orden de fecha. Otro caso sería cuando no interesan las mayúsculas y minúsculas, pero se quiere que si una clave aBC estaba antes que AbC, en el resultado ambas claves aparezcan juntas y en el orden original: aBC, AbC. Cuando los elementos son indistinguibles (porque cada elemento se ordena por la clave completa) la estabilidad no interesa. Los algoritmos de ordenamiento que no son estables se pueden implementar para que sí lo sean. Una manera de hacer esto es modificar artificialmente la clave de ordenamiento de modo que la posición original en la lista participe del ordenamiento en caso de coincidencia.Los algoritmos se distinguen por las siguientes características:Complejidad computacional (peor caso, caso promedio y mejor caso) en términos de n'', el tamaño de la lista o arreglo. Para esto se usa el concepto de ''orden de una función y se usa la notación O(n''). El mejor comportamiento para ordenar (si no se aprovecha la estructura de las claves) es O(''n log n''). Los algoritmos más simples son cuadráticos, es decir O(''n²). Los algoritmos que aprovechan la estructura de las claves de ordenamiento (p. ej. bucket sort) pueden ordenar en O(kn) donde k'' es el tamaño del espacio de claves. Como dicho tamaño es conocido a priori, se puede decir que estos algoritmos tienen un desempeño lineal, es decir O(''n).Uso de memoria y otros recursos computacionales. También se usa la notación O(n).EstabilidadLos algoritmos de ordenamiento estable mantienen un relativo preorden total. Esto significa que un algoritmo es estable solo cuando hay dos registros R'' y ''S con la misma clave y con R'' apareciendo antes que ''S en la lista original.Cuando elementos iguales (indistinguibles entre sí), como números enteros, o más generalmente, cualquier tipo de dato en donde el elemento entero es la clave, la estabilidad no es un problema. De todas formas, se asume que los siguientes pares de números están por ser ordenados por su primer componente:(4, 1)  (3, 7)  (3, 1)  (5, 6)En este caso, dos resultados diferentes son posibles, uno de los cuales mantiene un orden relativo de registros con claves iguales, y una en la que no:(3, 7)  (3, 1)  (4, 1)  (5, 6)   (orden mantenido)
(3, 1)  (3, 7)  (4, 1)  (5, 6)   (orden cambiado)Los algoritmos de ordenamiento inestable pueden cambiar el orden relativo de registros con claves iguales, pero los algoritmos estables nunca lo hacen. Los algoritmos inestables pueden ser implementados especialmente para ser estables. Una forma de hacerlo es extender artificialmente el cotejamiento de claves, para que las comparaciones entre dos objetos con claves iguales sean decididas usando el orden de las entradas original. Recordar este orden entre dos objetos con claves iguales es una solución poco práctica, ya que generalmente acarrea tener almacenamiento adicional.Ordenar según una clave primaria, secundaria, terciara, etc., puede ser realizado utilizando cualquier método de ordenamiento, tomando todas las claves en consideración (en otras palabras, usando una sola clave compuesta). Si un método de ordenamiento es estable, es posible ordenar múltiples ítems, cada vez con una clave distinta. En este caso, las claves necesitan estar aplicadas en orden de aumentar la prioridad.Ejemplo: ordenar pares de números, usando ambos valores(4, 1)  (3, 7)  (3, 1)  (4, 6) (original)(4, 1)  (3, 1)  (4, 6)  (3, 7) (después de ser ordenado por el segundo valor)
(3, 1)  (3, 7)  (4, 1)  (4, 6) (después de ser ordenado por el primer valor)Por otro lado:(3, 7)  (3, 1)  (4, 1)  (4, 6) (después de ser ordenado por el primer valor)
(3, 1)  (4, 1)  (4, 6)  (3, 7) (después de ser ordenando por el segundo valor,
                                 el orden por el primer valor es perturbado)Listado de algoritmos de ordenamientoAlgunos algoritmos de ordenamiento agrupados según estabilidad tomando en cuenta la complejidad computacional.EstablesNombre traducidoNombre originalComplejidadMemoriaMétodoOrdenamiento de burbujaBubblesortO]](n²)O]](1)IntercambioOrdenamiento de burbuja bidireccionalCocktail sortO]](n²)O]](1)IntercambioOrdenamiento por inserciónInsertion sortO]](n²)O]](1)InserciónOrdenamiento por casillerosBucket sortO]](n)O(n)No comparativoOrdenamiento por cuentasCounting sortO]](n''+''k)O(n''+''k)No comparativoOrdenamiento por mezclaMerge sortO]](n'' log ''n)O]](n)MezclaOrdenamiento con árbol binarioBinary tree sortO]](n'' log ''n)O(n)InserciónPigeonhole sortO]](n''+''k)O(k)Ordenamiento RadixRadix sortO]](nk)O(n)No comparativoStupid sortO]](n³) versión recursivaO(n²)Gnome sortO]](n²)InestablesNombre traducidoNombre originalComplejidadMemoriaMétodoOrdenamiento ShellShell sortO]](n1.25)O]](1)InserciónComb sortO]](n'' log ''n)O]](1)IntercambioOrdenamiento por selecciónSelection sortO]](n²)O]](1)SelecciónOrdenamiento por montículosHeapsortO]](n'' log ''n)O]](1)SelecciónSmoothsortO]](n'' log ''n)O]](1)SelecciónOrdenamiento rápidoQuicksortO]](n'' log ''n),peor caso: O(n²)O]](log n)ParticiónSeveral Unique SortO]](n'' u),peor caso: O(''n²);u=n; u = número único de registrosCuestionables, imprácticosNombre traducidoNombre originalComplejidadMemoriaMétodoBogosortO]](n'' × ''n!), peor: no terminaPancake sortingO]](n), excepto enmáquinas de Von NeumannRandomsortReferenciasEnlaces externosExplicación de los distintos métodos de ordenamiento en Java. (pdf)Discusión sobre varios algoritmos de ordenación y sus características (licencia GFDL) (pdf)Animación de algoritmos de ordenamientoAnimación de algoritmos de ordenamiento (en inglés)ALT: Algorithm Learning Tool. Herramienta de apoyo a la enseñanza de algoritmos que muestra gráficamente su funcionamiento. Permite implementar algoritmos propios y realizar una ejecución dinámica e interactivaCódigos de Ordenamiento en PythonAlgoritmo de ordenamiento Categoría:Algoritmos de ordenamientoar:خوارزميات الترتيب ca:Algorisme d'ordenació cs:Řadicí algoritmus da:Sorteringsalgoritme de:Sortierverfahren en:Sorting algorithm fa:الگوریتم مرتب‌سازی fi:Lajittelualgoritmi fr:Algorithme de tri he:מיון (מדעי המחשב) hu:Rendezés (programozás) is:Röðunarreiknirit it:Algoritmo di ordinamento ja:ソート ko:정렬 알고리즘 ku:Algorîtmayê rêzkerdişî lb:Zortéieralgorithmus lt:Rikiavimo algoritmas nl:Sorteeralgoritme no:Sorteringsalgoritme pl:Sortowanie pt:Algoritmo de ordenação ru:Алгоритм сортировки sv:Sorteringsalgoritm th:ขั้นตอนวิธีการเรียงลำดับ tr:Sıralama algoritması uk:Алгоритми сортування vi:Thuật toán sắp xếp zh:排序算法