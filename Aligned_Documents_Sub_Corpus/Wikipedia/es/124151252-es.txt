Un Árbol biselado o Árbol Splay es un Árbol binario de búsqueda auto-balanceable, con la propiedad adicional de que a los elementos accedidos recientemente se accederá más rápidamente en accesos posteriores. Realiza operaciones básicas como pueden ser la inserción, la búsqueda y el borrado en un tiempo del orden de O(log n). Para muchas secuencias no uniformes de operaciones, el árbol biselado se comporta mejor que otros árboles de búsqueda, incluso cuando el patrón específico de la secuencia es desconocido. Esta estructura de datos fue inventada por Robert Tarjan y Daniel Sleator.Todas las operaciones normales de un árbol binario de búsqueda son combinadas con una operación básica, llamada biselación. Esta operación consiste en reorganizar el árbol para un cierto elemento, colocando éste en la raíz. Una manera de hacerlo es realizando primero una búsqueda binaria en el árbol para encontrar el elemento en cuestión y, a continuación, usar rotaciones de árboles de una manera específica para traer el elemento a la cima. Alternativamente, un algoritmo "de arriba a abajo" puede combinar la búsqueda y la reorganización del árbol en una sola fase.Ventajas e inconvenientesEl buen rendimiento de un árbol biselado depende del hecho de que es auto-balanceado, y además se optimiza automáticamente. Los nodos accedidos con más frecuencia se moverán cerca de la raíz donde podrán ser accedidos más rápidamente. Esto es una ventaja para casi todas las aplicaciones, y es particularmente útil para implementar cachés y algoritmos de recolección de basura; sin embargo, es importante apuntar que para un acceso uniforme, el rendimiento de un árbol biselado será considerablemente peor que un árbol de búsqueda binaria balanceado simple.Los árboles biselados también tienen la ventaja de ser consideradamente más simples de implementar que otros árboles binarios de búsqueda auto-balanceados, como pueden ser los árboles Rojo-Negro o los árboles AVL, mientras que su rendimiento en el caso promedio es igual de eficiente. Además, los árboles biselados no necesitan almacenar ninguna otra información adicional a parte de los propios datos, minimizando de este modo los requerimientos de memoria. Sin embargo, estas estructuras de datos adicionales proporcionan garantías para el peor caso, y pueden ser más eficientes en la práctica para el acceso uniforme.Uno de los peores casos para el algoritmo básico del árbol biselado es el acceso secuencial a todos los elementos del árbol de forma ordenada. Esto deja el árbol completamente des balanceado (son necesarios n accesos, cada uno de los cuales del orden de O(log n) operaciones). Volviendo a acceder al primer elemento se dispara una operación que toma del orden de O(n) operaciones para volver a balancear el árbol antes de devolver este primer elemento. Esto es un retraso significativo para esa operación final, aunque el rendimiento se amortiza si tenemos en cuenta la secuencia completa, que es del orden de O(log n). Sin embargo, investigaciones recientes muestran que si aleatoriamente volvemos a balancear el árbol podemos evitar este efecto de desbalance y dar un rendimiento similar a otros algoritmos de auto-balanceo.Al contrario que otros tipos de árboles auto balanceados, los árboles biselados trabajan bien con nodos que contienen claves idénticas. Incluso con claves idénticas, el rendimiento permanece amortizado del orden de O(log n). Todas las operaciones del árbol preservan el orden de los nodos idénticos dentro del árbol, lo cual es una propiedad similar a la estabilidad de los algoritmos de ordenación. Un operación de búsqueda cuidadosamente diseñada puede devolver el nodo más a la izquierda o más a la derecha de una clave dada.OperacionesBúsquedaLa búsqueda de un valor de clave en un árbol biselado tiene la característica particular de que modifica la estructura del árbol. El descenso se efectúa de la misma manera que un árbol binario de búsqueda, pero si se encuentra un nodo cuyo valor de clave coincide con el buscado, se realiza una biselación de ese nodo. Si no se encuentra, el nodo biselado será aquel que visitamos por último antes de descartar la búsqueda. Así, la raíz contendrá un sucesor o predecesor del nodo buscado.InserciónEs igual que en el árbol binario de búsqueda con la salvedad de que se realiza una biselación sobre el nodo insertado. Además, si el valor de clave a insertar ya existe en el árbol, se bisela el nodo que lo contiene.ExtracciónEsta operación requiere dos biselaciones. Primero se busca el nodo que contiene el valor de clave que se debe extraer. Si no se encuentra, el árbol es biselado en el último nodo examinado y no se realiza ninguna acción adicional. Si se encuentra, el nodo se bisela y se elimina. Con esto el árbol se queda separado en dos mitades, por lo que hay que seleccionar un nodo que haga las veces de raíz. Al ser un árbol binario de búsqueda y estar todos los valores de clave ordenados, podemos elegir como raíz el mayor valor del subárbol izquierdo o el menor valor de clave del derecho.Operación de BiselaciónEsta operación traslada un nodo x''', que es el nodo al que se accede, a la raíz . Para realizar esta operación debemos rotar el árbol de forma que en cada rotación el nodo '''x está más cerca de la raíz. Cada biselación realizada sobre el nodo de interés mantiene el árbol parcialmente equilibrado y además los nodos recientemente accedidos se encuentran en las inmediaciones de la raíz. De esta forma amortizamos el tiempo empleado para realizar la biselación.Podríamos distinguir 3 casos generales:Caso 1: x''' es hijo izquierdo o derecho de la raíz, '''p.Caso 2: x''' es hijo izquierdo de '''p y este a su vez hijo izquierdo de q o bien ambos son hijos derechos.Caso 3: x''' es hijo izquierdo de '''p y este a su vez hijo derecho de q o viceversa.CASO 1:Si x''' es hijo izquierdo de '''p entonces realizaremos una rotación simple derecha. En caso de que x sea el derecho la rotación que deberemos realizar es simple izquierda.450px||left450px||centerCASO 2:Si x''' es hijo y nieto izquierdo de '''p y q''', respectivamente. Entonces debemos realizar rotación doble a la derecha, en caso de que '''x sea hijo y nieto derecho de p''' y '''q la rotación será doble izquierda.450px||left450px||centerCASO 3:En caso de que x''' sea hijo izquierdo de '''p y nieto derecho de q''' realizaremos una rotación simple derecha en el borde entre '''x y p''' y otra simple izquierda entre '''x y q'''. En caso contrario, '''x sea hijo derecho y nieto izquierdo de q, la rotaciones simples será izquierda y después derecha.450px||left450px||centerTeoremas de rendimientoHay muchos teoremas y conjeturas con respecto al peor caso en tiempo de ejecución para realizar una secuencia S'' de ''m accesos en un árbol biselado con n elementos.Teorema del balanceEl coste de realizar la secuencia de accesos S'' es del orden de O(m(logn + 1) + nlogn). En otras palabras, los árboles biselados se comportan tan bien como los árboles de búsqueda binaria con balanceo estático en secuencias de al menos ''n accesos.Teorema de optimalidad estáticaSea q_i el número de veces que se accede al elemento i'' en ''S. El coste de realizar la secuencia de accesos S'' es del orden de O\left (m+\sum_^n q_i\log\frac\right). En otras palabras, los árboles biselados se comportan tan bien como los árboles binarios de búsqueda estáticos óptimos en las secuencias de al menos ''n accesos.Teorema &quot;Static Finger&quot;Sea i_j el elemento visitado en el j''-ésimo acceso de ''S, y sea f'' un elemento fijo ("finger"). El coste de realizar la secuencia de accesos ''S es del orden de O\Bigl(m+n\log n+\sum_^m \log(|i_j-f|+1)\Bigr).Teorema &quot;Working Set&quot;Sea t(j) el numero de elementos distintos accedidos desde la última vez que se accedió a j'' antes del instante ''i. El coste de realizar la secuencia de accesos S es del orden de O\Bigl(m+n\log n+\sum_^m \log(t(j)+1)\Bigr).Teorema &quot;Dynamic Finger&quot;El coste de realizar la secuencia de accesos S es del orden de O\Bigl(m+n+\sum_^m \log(|i_-i_j|+1)\Bigr).Teorema &quot;Scanning&quot;También conocido como Teorema de Acceso Secuencial. El acceso a los n elementos de un árbol biselado en orden simétrico es de orden exácto \Theta(n), independientemente de la estructura inicial del árbol. El límite superior más ajustado demostrado hasta ahora es 4,5 nConjetura de optimalidad dinámicaAdemás del las garantías probadas del rendimiento de los árboles biselados, en el documento original de Sleator y Tarjan hay una conjetura no probada de gran interés. Esta conjetura se conoce como la conjetura de optimalidad dinámica, y básicamente sostiene que los árboles biselados se comportan tan bien como cualquier otro algoritmo de búsqueda en árboles binarios hasta un factor constante.Conjetura de optimalidad dinámica: Sea A'' cualquier algoritmo de búsqueda binaria en árboles que accede a un elemento ''x atravesando el camino desde la raíz hasta x'', a un coste de ''d(x) + 1, y que entre los accesos puede hacer cualquier rotación en el árbol a un coste de 1'' por rotación. Sea ''A(S) el coste para que A'' realice la secuencia ''S de accesos. Entonces el coste de realizar los mismos accesos para un árbol biselado es del orden O(n + A (S)).Existen varios corolarios de la conjetura de optimalidad dinámica que permanecen sin probar:Conjetura Transversal: Sean T_1 y T_2 dos árboles biselados que contienen los mismos elementos. Sea S'' la secuencia obtenida tras visitar los elementos de T_2 en preorden. El coste total para realizar la secuencia ''S de accesos en T_1 es del orden de O(n).Conjetura Deque: Sea S'' una secuencia de ''m operaciones de cola doblemente terminada (push, pop, inject, eject). Entonces el coste para la realización de esta secuencia de operaciones S en un árbol biselado es del orden de O(m + n).Conjetura Split: Sea S'' cualquier permutación de los elementos del árbol biselado. Entonces el coste de la eliminación de los elementos en el orden ''S es del orden de O(n).Biselados, Arbolescs:Splay strom de:Splay-Baum en:Splay tree fi:Splay-puu fr:Arbre splay it:Albero splay ja:スプレー木 nl:Splayboom pl:Drzewo splay ru:Расширяющееся дерево th:Splay tree zh:伸展树Código de ejemplo&lt;source lang=&quot;java&quot;&gt;/** SplayTreeApplet:
* 
* The applet demonstrates the Splay Tree. It takes textual commands in a TextArea 
* and when the user clicks on the Execute button, it processes the commands, updating
* the display as it goes.
* 
* @author Hyung-Joon Kim. CSE373, University of Washington.
* 
* Copyrights Note: 
* This applet is extended from FullHuffmanApplet created by Prof. Steve Tanimoto, 
* Department of Computer Science and Engineering, University of Washington.  
* The setup of applet panels and the tree display methods are apprecicatively reused.
*  
*/import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.*;public class SplayTreeApplet extends JApplet implements ActionListener, Runnable class ScrolledPanel extends JPanel  class MyScrollPane extends JScrollPane  public void actionPerformed(ActionEvent e) if (e.getActionCommand().equals("History"))  historyFrame.show();  // The following is executed by a separate thread for the display. public void run()  userInputText.setText(""); // Erase all the processed input. // Helper function called by the run method above: void process(String command, StringTokenizer lines)  String firstToken = st.nextToken(); if (firstToken.startsWith(";"))  history.appendText(command + "\n"); statusLine.setText(command); if (firstToken.equals("RESET"))  if (firstToken.equals("DELAY"))  catch(NumberFormatException e)  statusLine.setText("delay = " + delay);  history.appendText("; delay is now " + delay + "\n"); return;  if (firstToken.equals("INSERT"))  int data = (new Integer(arg1)).intValue(); if (data  99)  theSplayTree.insert(data); // insert an elementcheckScrolledPanelSize(); updateDisplay(); if (theSplayTree.statMode)   theSplayTree.getRoot().oldFam = null; // reset the old family of the root return;  if (firstToken.equals("FIND"))  int data = (new Integer(arg1)).intValue(); String msg = "";// Check if data is already in the SplayTree and display the result. SplayTree node = theSplayTree.find(data); if ( node == null)  else  report(msg); checkScrolledPanelSize(); updateDisplay(); if (theSplayTree.statMode)   theSplayTree.getRoot().oldFam = null; // reset the old family of the root return;  if (firstToken.equals("DELETE"))  int data = (new Integer(arg1)).intValue();theSplayTree.delete(data); // delete an elementcheckScrolledPanelSize(); updateDisplay(); if (theSplayTree.statMode)   theSplayTree.getRoot().oldFam = null; // reset the old family of the root return;  if (firstToken.equals("FIND-MIN"))   theSplayTree.getRoot().oldFam = null; // reset the old family of the root return;  if (firstToken.equals("FIND-MAX"))   theSplayTree.getRoot().oldFam = null; // reset the old family of the root return;  if (firstToken.equals("STAT-MODE"))  theSplayTree.statMode = true; updateDisplay(); return;  history.appendText("Splay Tree command\n"); statusLine.setText("Unknown Spaly Tree command: " + command); // Here is a "middleman" method that updates the display waiting with // the current time delay after each repaint request. void updateDisplay()  catch(InterruptedException e)   int getInt(String s)  catch(Exception e)  return n; /* The following computes the height of the display area needed by the current * heap, and if it won't fit in the scrolled panel, it enlarges the scrolled panel. */ void checkScrolledPanelSize()  /** * Splay Tree Class: * * This inner class is a data structure to be demostrated. Integer numbers are assigned * to the data field of Splay Tree, and each node of Splay Tree has left child, right child, * and parent. When a data is accessed by any operations such as FIND, INSERT, etc, Splay Tree * performs a sequence of self-reconstructing processes, so called 'splay', in order to bring * the most-recently-accessed node to the root of the tree. As a result, the nodes near the most- * recently-accessed node become available for a fast accesss in futre. * * @author Hyung-Joon Kim, CSE373, University of Washington. * */ public class SplayTree  // no hace nada/** * Constructor: Crea un único nodo con los datos asignados. * @param x comparable data(integer number) */ SplayTree(int x) /** * Comprueba si un nodo del árbol es externo - es decir, el nodo no tiene subarboles, es decir que sea una hoja. * @return true si el nodo es externo, sino false. */ boolean isExternal() /** * Comprueba si un nodo es la raíz del árbol Splay * @return true si el nodo es la raíz, sino falso. */ boolean isRoot() /** * Asigna un nodo nuevo a la raíz del árbol Splay. * @param root toma el valor de node, que es la nueva raiz. */ void setRoot(SplayTree node) /** * Accede a la raíz del árbol Splay. * @return la raíz del árbol Splay. */ SplayTree getRoot() /** * Comprueba si un nodo es el hijo izquierdo de su padre. * @return true si el nodo es el hijo izquierdo de su padre, sino false. */ boolean isLeftSubtree() /** * Comprueba si un nodo es el hijo derecho de su padre. * @return true si el nodo es el hijo derechoo de su padre, sino false. */ boolean isRightSubtree() /** * Encuentra el valor mínimo de los datos guardados en el Árbol Splay * @param T el nodo que funciona como raíz del árboles (o cualquier subarbol del Árbol Splay). * El valor se busca en el subárbol izquierdo debido a la filosofía de un AB.B * @return un nodo cuyo dato es el valor mínimo en el Árbol Splay. */ SplayTree findMin(SplayTree T)  else if (T.leftSubtree == null) /** *Buscar el máximo valor de los datos Árbol Splay. *@param T el nodo que funciona como raíz del árboles (o cualquier subarbol del Árbol Splay). * El valor se busca en el subárbol derecho debido a la filosofía de un AB.B * @return un nodo cuyo dato es el valor máximo en el Árbol Splay. */ SplayTree findMax(SplayTree T)  else if (T.rightSubtree == null)  return findMax(T.rightSubtree); // Encuentra recursivamente en el subárbol derecho el valor mínimo. /** * Encuentra un valor buscado en el árbol secuencialmente. * Si lo encuentra llama al método splay() para ajustar el árbol de tal manera que el nodo visitado quede más cerca de la raíz. * @param element valor a buscar en el Árbol Splay. * @return el nodo, si fue encontrado, en la que se realiza splaying. nulo si no se encuentra. */ SplayTree find(int element)  else if (T.element  element)  else   if (T == null)  else  /** * Inserta un nodo en el árbol Splay. Después de la inserción, el Árbol Splay realiza secuencial * Insert a node into the Splay Tree. After insertion, the Splay Tree performs sequential * self-reconstructing processes, so called splay, in order to bring the inserted node * up to the root of the tree. * @param element comparable data which will be inserted into the Splay Tree. */ void insert(int element)  SplayTree parent = null; SplayTree T = root; // Busca la ubicación adecuada para insertar el nodo, utilizando las propiedades de un AB,B. while (T != null)  else if (T.element  node.element)  else   if (node.element == parent.element)  //Inserta el nodo en el árbol Splay el la posición que se obtuvo en el while anterior. if (parent.element  node.element)   else   splay(node); // Despues de la inserción, se biselado el nodo. /** * This is a helper method for Delete method. It replaces a node with a new node so that * the new node is connected to the parent of the previous node. Note that it should take * care of the pointers of both direction (parent  child). * @param T a node to be replaced. * @param newT a node to replace T. */ void replace(SplayTree T, SplayTree newT)   else   else    /** * Delete a node from the Splay Tree. When a node is deleted, its subtrees should * be reconnected to the Splay Tree somehow without violating the properties of BST. * If a node with two children is deleted, a node with the minimum-valued element * in the right subtrees replaces the deleted node. It does NOT guarantee the balance * of the Splay Tree. * @param x an element to be deleted from the Splay Tree. */ void delete(int x)  else if (node.element  x)  else   if (node == null)  else  // The node has at least one child, also the node might be the root else if (node.leftSubtree == null)  else if (node.rightSubtree == null)  else  else  else  // Replace the node with the succesive node, updating subtrees as well replace(node, newNode); newNode.leftSubtree = node.leftSubtree; newNode.rightSubtree = node.rightSubtree;   String msg = x + " is succesively deleted from the Splay Tree."; report(msg); // Finally, splaying at the parent of the deleted node. if (!wasRoot)  else  // Delete the node completely node.leftSubtree = null; node.rightSubtree = null; node.parentTree = null;  /** * Splay a node until it reaches up to the root of the Splay Tree. Depending on the location * of a target node, parent, and grandparent, splaying applies one of Zig, Zig-Zig, or Zig-Zag * rotation at each stage. This method is called when a data is accessed by any operations. * @param T a target node at which splaying is performed. */ void splay(SplayTree T)  else rotation(T); // Zig rotation rotateCount++;  else  else rotation(p); rotation(T); rotateCount++;  else  else rotation(T); rotation(T); rotateCount++;    // Report additional statistics of rotations if (statMode)  splayStat = ""; rotateCount = 0; // after splaying(and reporting), reset the variables /** * Rotate subtrees of the Splay Tree. It updates subtrees of a grandparent, if exists, for * doulbe rotations, and performs single rotation depending on whether a node is left * child or right child. * @param T a node at which single rotation should be performed. */ void rotation(SplayTree T)  if (!T.isRoot())  else   else  // Rotate from left if (wasLeft)  // Now rotate T, so T's parent becomes T's right child T.rightSubtree = p; if (p != null)   else  // Now rotate T, so T's parent becomes T's left child T.leftSubtree = p; if (p != null)    /** * Self painting method. * @param g graphic object * @param xpos x-cordinate of a node in cartesian plane * @param ypos y-cordinate of a node in cartesian plane */ void paint(Graphics g, int xpos, int ypos) /** * Actually paint the tree by drawing line, node(circle), and data(integer) * @param g graphic object * @param xpos x-cordinate of a node in cartesian plane * @param ypos y-cordinate of a node in cartesian plane */ void paintHelper(Graphics g, int xpos, int ypos)  if (! isExternal())  if (rightSubtree != null)  g.setColor(new Color(102,0,204)); g.fillOval(xpos + column*nodeHorizSpacing -1, ypos + depth*nodeVertSpacing -1, nodeWidth+2, nodeHeight+2); g.setColor(treeColor); g.fillOval(xpos + column*nodeHorizSpacing, ypos + depth*nodeVertSpacing, nodeWidth, nodeHeight); g.setColor(Color.black);  if (isExternal())  else  if (rightSubtree != null)          /**
        * Inorder traversal, filling in the depth and the column index of each node
        * for display purposes. It should also deal with the case where a node has
        * only one child.
        * @param currentDepth  the current depth of a node
        * @return  the column index of the rightmost node.
        */int traverse(int currentDepth)  if (leftSubtree == null && rightSubtree != null)  if (leftSubtree != null) xcenter = column*nodeHorizSpacing + (nodeWidth / 2); ycenter = depth*nodeVertSpacing + nodeHeight - ycentering; if (rightSubtree != null)  else  return rm;  else  /** * Determine total column index of each node, filling a column index of * each node for display purpose. * @return total column index of the Splay Tree */ int treeColumns() /** * Determine the height of the Splay Tree * @param T a node that roots the Splay Tree * @return the height of the Splay Tree at the node */ int treeHeight(SplayTree T)  return (1 + Math.max( treeHeight(T.leftSubtree), treeHeight(T.rightSubtree))); /** * Get the width needed to display the tree * @return the width of the entire Splay Tree */ int getDisplayWidth()  /** * Get the height needed to display the tree * @return the height of the entire Splay Tree */ int getDisplayHeight()   //////////////////// End of SplayTree class //////////////////////** * OldFamilySplayTree Class: * * This inner class is to store old family members of a splayed node. * Therefore, after splaying, we can track the old family of the new root * and calculate the relative improvement in terms of depth. After splaying, * the most-recently-accessed data becomes available for O(1) access in the * next time. In addition, all family members also improve the access time * in future. This is a simple way to compare the cost of access to those * family memembers before splaying and after splaying. * * @author Hyung-Joon Kim * */ public class OldFamilySplayTree  if (T.leftSubtree != null)  if (T.rightSubtree != null)  if (T.isLeftSubtree())   else   /** * Calculate the average depth of all family member nodes. * This method can calculate the depth before splaying by being called * in the SPLAY method, and the depth after splaying by being called * after repaiting the tree since the depth will is updated in the * PAINT method. * @return the average depth of all family member nodes. */ double getFamilyDepth()  if (oldSibling != null)  if (oldLeftChild != null)  if (oldRightChild != null)  return famDepth;   //////////////////// End of OldFamilySplayTree class /////////////////////// Paint the Splay tree in a left-to-right sequence of trees. void paintTrees(Graphics g)  /* A handy function that reports a message to both the * status line of the applet and the history window. * Multiline messages are not fully visible in the status line. */ void report(String message) // Recuerden que es un applet Véase tambiénÁrbol (estructura de datos)Árbol binarioÁrbol binario de búsquedaÁrbol AVLÁrbol rojo-negroÁrbol multirramaEnlaces ExternosAlgoritmo&quot;Self-adjusting Binary Search Trees&quot;, Sleator and Tarjan (la publicación original en INGLÉS)ImplementacionesImplementaciones en C y Java por Sleator (uno de los inventores originales)Fichero de cabecera (.h) de implementación sencilla para FreeBSD