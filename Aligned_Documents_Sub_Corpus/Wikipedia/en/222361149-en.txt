''For lip-rounding in phonetics, see Labialisation and Roundedness. For other uses, see Rounding (disambiguation).Rounding is the process of reducing the number of significant digits in a number. The result of rounding is a "shorter" number having fewer non-zero digits yet similar in magnitude. The result is less precise but easier to use.For example: 73 rounded to the nearest ten is 70, because 73 is closer to 70 than to 80.Rounding can be analyzed as a form of quantization.There are many different rules that can be followed when rounding. Some of the more popular are described below.Common methodThis method is commonly used in mathematical applications, for example in accounting. It is the one generally taught in elementary mathematics classes. This method is also known as Symmetric Arithmetic Rounding or Round-Half-Up (Symmetric Implementation)Decide which is the last digit to keep.Increase it by 1 if the next digit is 5 or more (this is called rounding up)Leave it the same if the next digit is 4 or less (this is called rounding down)Examples:3.044 rounded to hundredths is 3.04 (because the next digit, 4, is less than 5).3.045 rounded to hundredths is 3.05 (because the next digit, 5, is 5 or more).3.0447 rounded to hundredths is 3.04 (because the next digit, 4, is less than 5).For negative numbers the absolute value is rounded and the sign is added back afterwards.Examples:−2.1349 rounded to hundredths is −2.13−2.1350 rounded to hundredths is −2.14==Round-to-even method== This method is also known as unbiased rounding, convergent rounding, statistician's rounding, Dutch rounding, Gaussian rounding, or bankers' rounding. It is identical to the common method of rounding except when the digit(s) following the rounding digit starts with a five and has no non-zero digits after it. The new algorithm is:Decide which is the last digit to keep.Increase it by 1 if the next digit is 6 or more, or a 5 followed by one or more non-zero digits.Leave it the same if the next digit is 4 or lessOtherwise, if all that follows the last digit is a 5 and possibly trailing zeroes; then change the last digit to the nearest even digit. That is, increase the rounded digit if it is currently odd; leave it if it is already even.With all rounding schemes there are two possible outcomes: increasing the rounding digit by one or leaving it alone. With traditional rounding, if the number has a value less than the half-way mark between the possible outcomes, it is rounded down; if the number has a value exactly half-way or greater than half-way between the possible outcomes, it is rounded up. The round-to-even method is the same except that numbers exactly half-way between the possible outcomes are sometimes rounded up&mdash;sometimes down.Although it is customary to round the number 4.5 up to 5, in fact 4.5 is no nearer to 5 than it is to 4 (it is 0.5 away from both). When dealing with large sets of scientific or statistical data, where trends are important, traditional rounding on average biases the data upwards slightly. Over a large set of data, or when many subsequent rounding operations are performed as in digital signal processing, the round-to-even rule tends to reduce the total rounding error, with (on average) an equal portion of numbers rounding up as rounding down. This generally reduces upwards skewing of the result.Round-to-even is used rather than round-to-odd as it reduces rounding to a final digit of 5, and so reduces the likelihood of error resulting from double rounding.Examples:3.016 rounded to hundredths is 3.02 (because the next digit (6) is 6 or more)3.013 rounded to hundredths is 3.01 (because the next digit (3) is 4 or less)3.015 rounded to hundredths is 3.02 (because the next digit is 5, and the hundredths digit (1) is odd)3.045 rounded to hundredths is 3.04 (because the next digit is 5, and the hundredths digit (4) is even)3.04501 rounded to hundredths is 3.05 (because the next digit is 5, but it is followed by non-zero digits)HistoryThe Round-to-even method has been the ASTM (E-29) standard since 1940. The origin of the terms unbiased rounding and statistician's rounding are fairly self-explanatory. In the 1906 4th edition of Probability and Theory of Errors http://historical.library.cornell.edu/cgi-bin/cul.math/docviewer?did=05170001&amp;view=50&amp;frames=0&amp;seq=48 Robert Woodward called this "the computer's rule" indicating that it was then in common use by human computers who calculated mathematical tables. Churchill Eisenhart's 1947 paper "Effects of Rounding or Grouping Data" (in Selected Techniques of Statistical Analysis, McGrawHill, 1947, Eisenhart, Hastay, and Wallis, editors) indicated that the practice was already "well established" in data analysis.The origin of the term bankers' rounding is more obscure. If this rounding method was ever a standard in banking, the evidence has proved extremely difficult to find. To the contrary, section 2 of the European Commission report The Introduction of the Euro and the Rounding of Currency Amounts http://ec.europa.eu/economy_finance/publications/publication1224_en.pdf suggests that there had previously been no standard approach to rounding in banking.Other methods of roundingOther methods of rounding exist, but use is mostly restricted to computers and calculators, statistics and science. In computers and calculators, these methods are used for one of two reasons: speed of computation or usefulness in certain computer algorithms. In statistics and science, the primary use of alternate rounding schemes is to reduce bias, rounding error and drift—these are similar to round-to-even rounding. They make a statistical or scientific calculation more accurate.Ease of computationOther methods of rounding include "round towards zero" (also known as truncation) and "round away from zero". These introduce more round-off error and therefore are rarely used in statistics and science; they are still used in computer algorithms because they are slightly easier and faster to compute. Two specialized methods used in mathematics and computer science are the floor (always round down to the nearest integer) and ceiling (always round up to the nearest integer).Statistical accuracyStochastic rounding is a method that rounds to the nearest integer, but when the two integers are equidistant (e.g., 3.5), then it is rounded up with probability 0.5 and down with probability 0.5. This reduces any drift, but adds randomness to the process. Thus, if you perform a calculation with stochastic rounding twice, you may not end up with the same answer. The motivation is similar to statistician's rounding.Rounding in an exact computationThe objective of rounding is often to get a number that is easier to use, at the cost of making it less precise. However, for evaluating a function with a discrete domain and range, rounding may be involved in an exact computation, e.g. to find the number of Sundays between two dates, or to compute a Fibonacci number. In such cases the algorithm can typically be set up such that computational rounding errors before the explicit rounding do not affect the outcome of the latter. For example, if an integer divided by 7 is rounded to an integer, a computational rounding error up to 1/14 in the division (which is much more than is possible in typical cases) does not affect the outcome. In the case of rounding down an integer divided by 7 this is not the case, but it applies e.g. if the number to be rounded down is an integer plus 1/2, divided by 7.Round functions in programming languagesCC99 specifies (in ):round(): round to nearest integer, halfway away from zerorint(), nearbyint(): round according to current floating-point rounding directionceil(): smallest integral value not less than argumentfloor(): largest integral value not greater than argumenttrunc(): round towards zeroThe current floating-point rounding direction may, depending on implementation, be retrieved and set using the fegetround()/fesetround() functions defined in ; the available directions are specified to be at least those in IEEE 854 (see IEEE 754#Rounding floating-point numbers) which include round-to-even, round-down, round-up, and round-to-zero.JavaBigDecimal: Supports "round up", "round down", "round floor", "round ceiling", "round half up", "round half down", "round half even" and even a "rounding unnecessary" mode.JavaScript:Uses Asymmetric Arithmetic RoundingMath.round(-3.5) gives -3.Common Lisp:Uses round-to-even(round -3.5) gives -4.Pascal:Round and RoundTo (nonstandard) use bankers' roundingStr (nonstandard), Write and FloatToStr (nonstandard) don't use bankers' roundingCeil(): smallest integral value not less than argumentFloor(): largest integral value not greater than argumentTrunc(): round towards zeroPerl:printf "%f" or sprintf "%f": use bankers' roundingint: chops off fractional part, rounding towards zeroPOSIX::ceil: smallest integral value not less than argumentPOSIX::floor: largest integral value not greater than argumentPHP:round(-3.5) gives -4.round(8.7352, 3) gives 8.735.round(4278.5, -2) gives 4300.Python:Current versions 2.5.x and prior use common rounding for POSITIVE numbers: round(0.5) is 1.0.Note that negative integer division is not rounded towards zero but always rounded down: 7/3=2, -7/3=-3.New version (3.0 aka Python 3000) may use round-to-even (else common rounding).Transitional version 2.6.x will be compatible with 2.5 (but is not yet as of Jan 08).As of 2.4, Python includes class Decimal in module decimal.Class Decimal provides exact numerical representation and several rounding modes.Visual Basic for Applications:Uses Round-Half-Even (Bankers' Rounding)? Round(2.5, 0) gives 2.http://support.microsoft.com/kb/194983Microsoft SQL Server:Uses either Symmetric Arithmetic Rounding or Symmetric Round Down (Fix) depending on argumentsSELECT Round(2.5, 0) gives 3.Microsoft Excel:Uses Symmetric Arithmetic Rounding= ROUND(2.5, 0) gives 3.= ROUND(3.5, 0) gives 4.= ROUND(-3.5, 0) gives -4Microsoft .NET FrameworkThe Convert.ToInt32(Double) function and similar forms uses Bankers' Rounding.Framework 2.0 introduced an overload of the System.Math.Round() function that allows the rounding type to be specified. The definition is here: http://msdn2.microsoft.com/en-us/library/ms131274(vs.80).aspx. It also introduced System.Decimal.Round static method which, by default, performs "bankers' rounding" of a Decimal. Other rounding modes can be used with this method by using the overload that takes a System.MidpointRounding enumeration (http://msdn.microsoft.com/en-us/library/system.midpointrounding.aspx).C#The (int) cast truncates the fractional part of the number, like System.Math.Floor(). Note that this is different from using the Convert class in the .NET Framework!Visual Basic .NETCType(value, Integer) uses bankers' rounding.The Round() function is not implemented in a consistent fashion among different Microsoft products for historical reasons.XSLT 1.0:Uses round half evenNegative zero in meteorologyIn meteorology, temperatures between 0.0 and −0.5 degrees (exclusive) may be rounded to −0 to indicate a temperature which is below zero, but not cold enough to be rounded to −1 or less. It is used especially in the Celsius scale, where below zero indicates freezing. It may be used, for example, to allow tallying of below-zero days.See alsoTruncationRound-off errorSignificant figuresNearest integer functionFalse precision−0 (number)External linksAn introduction to different rounding algorithms that is accessible to a general audience but especially useful to those studying computer science and electronics.A complete treatment of mathematical rounding. by John KennedyHow To Implement Custom Rounding Procedures by MicrosoftCategory:Arithmeticca:Arrodoniment cs:Zaokrouhlení da:Afrunding de:Rundung es:Redondeo fr:Arrondi ko:반올림 it:Arrotondamento he:עיגול (פעולה) nl:Afronden ja:端数処理 no:Avrunding pl:Zaokrąglanie pt:Arredondamento ru:Округление sl:Zaokrožanje sv:Avrundning zh:數值修約規則