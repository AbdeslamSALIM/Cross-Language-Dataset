In computing, a process is an instance of a computer program that is being sequentially executedKnott 1974, p.8 by a computer system that has the ability to run several computer programs concurrently.A computer program itself is just a passive collection of instructions, while a process is the actual execution of those instructions. Several processes may be associated with the same program; for example, opening up several windows of the same program often means more than one process is being executed. In the computing world, processes are formally defined by the operating system(s)(OS) running them and so may differ in detail from one OS to another.A single computer processor executes one or more (multiple) instructions at a time (per clock cycle), one after the other (this is a simplification; for the full story, see superscalar CPU architecture). To allow users to run several programs at once (e.g., so that processor time is not wasted waiting for input from a resource), single-processor computer systems can perform time-sharing. Time-sharing allows processes to switch between being executed and waiting (to continue) to be executed. In most cases this is done very rapidly, providing the illusion that several processes are executing 'at once'. (This is known as concurrency or multiprogramming.) Using more than one physical processor on a computer, permits true simultaneous execution of more than one stream of instructions from different processes, but time-sharing is still typically used to allow more than one process to run at a time. (Concurrency is the term generally used to refer to several independent processes sharing a single processor; simultaneity is used to refer to several processes, each with their own processor.) Different processes may share the same set of instructions in memory (to save storage), but this is not known to any one process. Each execution of the same set of instructions is known as an instance— a completely separate instantiation of the program.For security and reliability reasons most modern operating systems prevent direct communication between 'independent' processes, providing strictly mediated and controlled inter-process communication functionality.Sub-processes and multithreadingA process may split itself into multiple 'daughter' sub-processes or threads that execute in parallel, running different instructions on much of the same resources and data (or, as noted, the same instructions on logically different resources and data).Multithreading is useful when various 'events' are occurring in an unpredictable order, and should be processed in another order than they occur, for example based on response time constraints. Multithreading makes it possible for the processing of one event to be temporarily interrupted by an event of higher priority. Multithreading may result in more efficient CPU time utilization, since the CPU may switch to low-priority tasks while waiting for other events to occur.For example, a word processor could perform a spell check as the user types, without "freezing" the application - a high-priority thread could handle user input and update the display, while a low-priority background process runs the time-consuming spell checking utility. This results in that the entered text is shown immediately on the screen, while spelling mistakes are indicated or corrected after a longer time.Multithreading allows a server, such as a web server, to serve requests from several users concurrently. Thus, we can avoid that requests are left unheard if the server is busy with processing a request. One simple solution to that problem is one thread that puts every incoming request in a queue, and a second thread that processes the requests one by one in a first-come first-served manner. However, if the processing time is very long for some requests (such as large file requests or requests from users with slow network access data rate), this approach would result in long response time also for requests that do not require long processing time, since they may have to wait in queue. One thread per request would reduce the response time substantially for many users and may reduce the CPU idle time and increase the utilization of CPU and network capacity. In case the communication protocol between the client and server is a communication session involving a sequence of several messages and responses in each direction (which is the case in the TCP transport protocol used in for web browsing), creating one thread per communication session would reduce the complexity of the program substantially, since each thread is an instance with its own state and variables.In a similar fashion, multi-threading would make it possible for a client such as a web browser to communicate efficiently with several servers concurrently.A process that has only one thread is referred to as a single-threaded process, while a process with multiple threads is referred to as a multi-threaded process. Multi-threaded processes have the advantage over multi-process systems that they can perform several tasks concurrently without the extra overhead needed to create a new process and handle synchronised communication between these processes. However, single-threaded processes have the advantage of even lower overhead.RepresentationIn general, a computer system process consists of (or is said to 'own') the following resources:An image of the executable machine code associated with a program.Memory (typically some region of virtual memory); which includes the executable code, process-specific data (input and output), a call stack (to keep track of active subroutines and/or other events), and a heap to hold intermediate computation data generated during run time.Operating system descriptors of resources that are allocated to the process, such as file descriptors (Unix terminology) or handles (Windows), and data sources and sinks.Security attributes, such as the process owner and the process' set of permissions (allowable operations).Processor state (context), such as the content of registers, physical memory addressing, etc. The state is typically stored in computer registers when the process is executing, and in memory otherwise.The operating system holds most of this information about active processes in data structures called process control blocks (PCB).Any subset of resources, but typically at least the processor state, may be associated with each of the process' threads in operating systems that support threads or 'daughter' processes.The operating system keeps its processes separated and allocates the resources they need so that they are less likely to interfere with each other and cause system failures (e.g., deadlock or thrashing). The operating system may also provide mechanisms for inter-process communication to enable processes to interact in safe and predictable ways. Process management in multitasking operating systemsA multitasking* operating system may just switch between processes to give the appearance of many processes executing concurrently or simultaneously, though in fact only one process can be executing at any one time on a single-core CPU (unless using multi-threading or other similar technology).Some modern CPUs combine two or more independent processors and can execute several processes simultaneously - see Multi-core for more information. Another technique called simultaneous multithreading (used in Intel's Hyper-threading technology) can simulate simultaneous execution of multiple processes or threads.It is usual to associate a single process with a main program, and 'daughter' ('child') processes with any spin-off, parallel processes, which behave like asynchronous subroutines. A process is said to own resources, of which an image of its program (in memory) is one such resource. (Note, however, that in multiprocessing systems, many processes may run off of, or share, the same reentrant program at the same location in memory— but each process is said to own its own image of the program.)Processes are often called tasks in embedded operating systems. The sense of 'process' (or task) is 'something that takes up time', as opposed to 'memory', which is 'something that takes up space'. (Historically, the terms 'task' and 'process' were used interchangeably, but the term 'task' seems to be dropping from the computer lexicon.)The above description applies to both processes managed by an operating system, and processes as defined by process calculi.If a process requests something for which it must wait, it will be blocked. When the process is in the Blocked State, it is eligible for swapping to disk, but this is transparent in a virtual memory system, where blocks of memory values may be really on disk and not in main memory at any time. Note that even unused portions of active processes/tasks (executing programs) are eligible for swapping to disk. All parts of an executing program and its data do not have to be in physical memory for the associated process to be active.______________________________'*'Tasks and processes refer essentially to the same entity. And, although they have somewhat different terminological histories, they have come to be used as synonyms. Today, the term process is generally preferred over task, except when referring to 'multitasking', since the alternative term, 'multiprocessing', is too easy to confuse with multiprocessor (which is a computer with two or more CPUs).Process states , with arrows indicating possible transitions between states.]] Processes go through various process states which determine how the process is handled by the operating system kernel. The specific implementations of these states vary in different operating systems, and the names of these states are not standardised, but the general high-level functionality is the same.When a process is created, it needs to wait for the process scheduler (of the operating system) to set its status to "waiting" and load it into main memory from secondary storage device (such as a hard disk or a CD-ROM). Once the process has been assigned to a process''or'' by a short-term scheduler, a context switch is performed (loading the process into the process''or'') and the process state is set to "running" - where the process''or'' executes its instructions. If a process needs to wait for a resource (such as waiting for user input, or waiting for a file to become available), it is moved into the "blocked" state until it no longer needs to wait - then it is moved back into the "waiting" state. Once the process finishes execution, or is terminated by the operating system, it is moved to the "terminated" state where it waits to be removed from main memory.Particularly chapter 3, section 3.2, "process states", including figure 3.9 "process state transition with suspend states"Inter-process communication Processes can communicate with each other via Inter-process communication (IPC). This is possible for both processes running on the same machine and on different machines. The subject is a difficult one to discuss concisely, because it differs considerably from one operating system (OS) to another. However, a useful way to approach it is to consider the general mechanisms used in one form or another by most OS and to recognize that any given OS will only employ some subset of that universe. History By the early 60s computer control software had evolved from Monitor control software, e.g., IBSYS, to Executive control software, making it possible to do multiprogramming. Multiprogramming is a rudimentary form of multiprocessing in which several programs are run "at the same time" (i.e., concurrently) on a single uniprocessor. That is, several programs are allowed to share the CPU- a scarce resource. Since there was only one processor, there was no true simultaneous execution of different programs. Instead, the later computer 'monitor-type' control software (known by then also as 'Executive' systems), and early "operating systems," typically allowed execution of part of one program until it was halted by some missing resource (e.g., input), or until some slow operation (e.g., output) had completed. At that point, a second (or nth) program was started or restarted. To the user it appeared that all programs were executing "at the same time" (hence the term, concurrent).Shortly thereafter, the notion of a 'program' was expanded to the notion of an 'executing program and its context,' i.e., the concept of a process was born. This became necessary with the invention of re-entrant code. Threads came somewhat later. However, with the advent of time-sharing; computer networks; multiple-CPU, shared memory computers; etc., the old "multiprogramming" gave way to true multitasking, multiprocessing and, later, multithreading.See alsoChild processExitForkOrphan processParent processProcess groupProcess statesTaskThreadWaitZombie processProcess management (computing)NotesReferencesGary D. Knott (1974) A proposal for certain process management and intercommunication primitives ACM SIGOPS Operating Systems Review. Volume 8 , Issue 4 (October 1974). pp. 7 - 44External linksWhatIsProcess.com - Your guide to the inside. Category:Operating system technology Category:Concurrent computing *cs:Proces (počítač) de:Prozess (Informatik) es:Proceso (informática) fr:Processus (informatique) ko:프로세스 it:Processo (informatica) lt:Procesas (informatika) nl:Proces (informatica) ja:プロセス no:Prosess (informatikk) pl:Proces (informatyka) pt:Processos da gerência de projetos ru:Процесс (информатика) sk:Proces (informatika) sl:Proces (računalništvo) sv:Process (datorteknik) tr:İşlem (bilgisayar) uk:Стани процесу zh:行程