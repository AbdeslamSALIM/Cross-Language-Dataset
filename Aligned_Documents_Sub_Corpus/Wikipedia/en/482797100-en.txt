In computer science, Backus–Naur Form (BNF) is a metasyntax used to express context-free grammars: that is, a formal way to describe formal languages. John Backus and Peter Naur developed a context free grammar to define the syntax of a programming language by using two sets of rules: i.e., lexical rules and syntactic rules.BNF is widely used as a notation for the grammars of computer programming languages, instruction sets and communication protocols, as well as a notation for representing parts of natural language grammars. Many textbooks for programming language theory and/or semantics document the programming language in BNF.There are many extensions and variants of BNF, including Extended and Augmented Backus–Naur Forms (EBNF and ABNF).HistoryJohn Backus created the notation in order to express the grammar of ALGOL. At the first World Computer Congress, which took place in Paris in 1959, Backus presented "The syntax and semantics of the proposed international algebraic language of the Zurich ACM-GAMM Conference", a formal description of the international algebraic language(IAL) which was later called ALGOL 58. The formal language he presented was based on Emil Post's production system. Generative grammars were an active subject of mathematical study, e.g. by Noam Chomsky, who was applying them to the grammar of natural language.  Peter Naur (ALGOL 60, 1963) identified Backus's notation as Backus Normal Form, and simplified it to minimize the character set used, and, at the suggestion of Donald Knuth, his name was added in recognition of his contribution, his initial replacing the N for "Normal" since, Knuth argued, the BNF is "not a normal form in any sense".  The Backus–Naur Form or BNF grammars have significant similarities to 's grammar rules, and the notation is sometimes also referred to as Panini–Backus Form.P.Z. Ingerman (1967)IntroductionA BNF specification is a set of derivation rules, written as &lt;symbol&gt; ::= __expression__where  is a nonterminal, and the __expression__ consists of one or more sequences of symbols; more sequences are separated by the vertical bar, '|', indicating a choice, the whole being a possible substitution for the symbol on the left. Symbols that never appear on a left side are terminals. On the other hand, symbols that appear on a left side are non-terminals and are always enclosed between the pair .ExampleAs an example, consider this possible BNF for a U.S. postal address: &lt;postal-address&gt; ::= &lt;name-part&gt; &lt;street-address&gt; &lt;zip-part&gt;     &lt;name-part&gt; ::= &lt;personal-part&gt; &lt;last-name&gt; &lt;opt-jr-part&gt; &lt;EOL&gt; 
                   | &lt;personal-part&gt; &lt;name-part&gt; &lt;personal-part&gt; ::= &lt;first-name&gt; | &lt;initial&gt; &quot;.&quot; &lt;street-address&gt; ::= &lt;opt-apt-num&gt; &lt;house-num&gt; &lt;street-name&gt; &lt;EOL&gt;      &lt;zip-part&gt; ::= &lt;town-name&gt; &quot;,&quot; &lt;state-code&gt; &lt;ZIP-code&gt; &lt;EOL&gt;   &lt;opt-jr-part&gt; ::= &quot;Sr.&quot; | &quot;Jr.&quot; | &lt;roman-numeral&gt; | &quot;&quot; This translates into English as:A postal address consists of a name-part, followed by a street-address part, followed by a zip-code part.A name-part consists of either: a personal-part followed by a last name followed by an optional "jr-part" (Jr., Sr., or dynastic number) and end-of-line, or a personal part followed by a name part (this rule illustrates the use of recursion in BNFs, covering the case of people who use multiple first and middle names and/or initials).A personal-part consists of either a first name or an initial followed by a dot.A street address consists of an optional apartment specifier, followed by a house number, followed by a street name, followed by an end-of-line.A zip-part consists of a town-name, followed by a comma, followed by a state code, followed by a ZIP-code followed by an end-of-line.Note that many things (such as the format of a first-name, apartment specifier, ZIP-code, and Roman numeral) are left unspecified here. If necessary, they may be described using additional BNF rules.Further examplesBNF's syntax itself may be represented with a BNF like the following: &lt;syntax&gt; ::= &lt;rule&gt; | &lt;rule&gt; &lt;syntax&gt;
&lt;rule&gt; ::= &lt;opt-whitespace&gt; &quot;&lt;&quot; &lt;rule-name&gt; &quot;&gt;&quot; &lt;opt-whitespace&gt; &quot;::=&quot; 
           &lt;opt-whitespace&gt; &lt;expression&gt; &lt;line-end&gt;
&lt;opt-whitespace&gt; ::= &quot; &quot; &lt;opt-whitespace&gt; | &quot;&quot;  &lt;!-- &quot;&quot; is empty string, i.e. no whitespace --&gt;
&lt;expression&gt; ::= &lt;list&gt; | &lt;list&gt; &quot;|&quot; &lt;expression&gt;
&lt;line-end&gt; ::= &lt;opt-whitespace&gt; &lt;EOL&gt; | &lt;line-end&gt; &lt;line-end&gt;
&lt;list&gt; ::= &lt;term&gt; | &lt;term&gt; &lt;opt-whitespace&gt; &lt;list&gt;
&lt;term&gt; ::= &lt;literal&gt; | &quot;&lt;&quot; &lt;rule-name&gt; &quot;&gt;&quot;
&lt;literal&gt; ::= '&quot;' &lt;text&gt; '&quot;' | &quot;'&quot; &lt;text&gt; &quot;'&quot; &lt;!-- actually, the original BNF did not use quotes --&gt; This assumes that no whitespace is necessary for proper interpretation of the rule.  represents the appropriate line-end specifier (in ASCII, carriage-return and/or line-feed, depending on the operating system).  and  are to be substituted with a declared rule's name/label or literal text, respectively.VariantsThere are many variants and extensions of BNF, generally either for the sake of simplicity and succinctness, or to adapt it to a specific application. One common feature of many variants is the use of regexp repetition operators such as * and +. The Extended Backus–Naur Form (EBNF) is a common one. In fact the example above is not the pure form invented for the ALGOL 60 report. The bracket notation "[]" was introduced a few years later in IBM's PL/I definition but is now universally recognised. ABNF is another extension commonly used to describe IETF protocols.Parsing expression grammars build on the BNF and regular expression notations to form an alternative class of formal grammar, which is essentially analytic rather than generative in character.Many BNF specifications found online today are intended to be human readable and are non-formal. These often include many of the following syntax rules and extensions:Optional items enclosed in square brackets. E.g. &lt;item-x&gt;Items repeating 0 or more times are enclosed in curly brackets or suffixed with an asterisk. E.g.  ::=  Items repeating 1 or more times are followed by a '+'Terminals may appear in bold and NonTerminals in plain text rather than using italics and angle bracketsAlternative choices in a production are separated by the ‘|’ symbol. E.g.,  | Where items need to be grouped they are enclosed in simple parenthesesSee alsoExtended Backus–Naur Form.Ashtadhyayi (Sanskrit grammar with mathematical structure).Syntax diagram (Railroad diagram).GOLD BNF parser.GNU bison GNU version of yacc.Wirth syntax notation An alternative to BNF from 1977.Yacc parser generator (used with Lex pre-processor).ANTLR Another parser generator written in Java.John BackusReferences External linksAlgol-60 BNF, the original BNF.Sample grammars at the BNF Web club.http://compilers.iecc.com/comparch/article/93-07-017 contains a posting on news:comp.compilers that explains some of the history of the two names (Backus–Naur Form vs. Backus Normal Form).Article BNF and EBNF: What are they and how do they work? by Lars Marius Garshol.RFC 4234 Augmented BNF for Syntax Specifications: ABNFComparision of different variants of BNFSyntax diagram of EBNFGeneration of syntax diagrams from EBNFCategory:Formal languages Category:Compiler theorycs:Backus-Naurova forma da:BNF de:Backus-Naur-Form es:Backus-Naur form fr:Forme de Backus-Naur gl:Backus-Naur Form ko:바쿠스-나우르 표기법 hr:Backus-Naurov oblik is:BNF it:Backus-Naur Form ka:ბეკუს-ნაურის ფორმალიზმი hu:Backus–Naur forma nl:Backus-Naur-formalisme ja:バッカス・ナウア記法 pl:Notacja BNF pt:Formalismo de Backus-Naur ru:Форма Бэкуса — Наура sr:Бекус-Наурова форма fi:Backus–Naur-muoto sv:Backus-Naur-form ta:பேக்கசு-நார் முறை tr:Backus-Naur form uk:Нотація Бекуса-Наура zh:巴科斯范式