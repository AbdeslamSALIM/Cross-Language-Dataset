I²C (Inter-Integrated Circuit) is a multi-master serial computer bus invented by Philips that is used to attach low-speed peripherals to a motherboard, embedded system, or cellphone. The name is pronounced eye-squared-see or eye-two-see. As of October 1, 2006, no licensing fees are required to implement the I²C protocol. However, fees are still required in order to "officially" allocate I²C slave addresses.I²C Licensing Information SMBus is a subset of I²C that defines stricter electrical and protocol conventions. One purpose of SMBus is to promote robustness and interoperability. Accordingly, modern I²C systems incorporate policies and rules from SMBus, and the line between these two standards is often blurred in practice.Design) and three slave nodes (an ADC, a DAC, and another microcontroller) with pull-up resistors Rp]]I²C uses only two bidirectional open-drain lines, Serial Data (SDA) and Serial Clock (SCL), pulled up with resistors. Typical voltages used are +5 V or +3.3 V although systems with other, higher or lower, voltages are permitted.The I²C reference design has a 7-bit address space with 16 reserved addresses, so a maximum of 112 nodes can communicate on the same bus. The most common I²C bus modes are the 100 kbit/s standard mode and the 10 kbit/s low-speed mode, but clock frequencies down to DC are also allowed. Recent revisions of I²C can host more nodes and run faster (400 kbit/s Fast mode, 1 Mbit/s Fast mode plus or Fm+, and 3.4 Mbit/s High Speed mode), and also support other extended features, such as 10-bit addressing.The maximum number of nodes is limited by the address space, and also by the total bus capacitance of 400&nbsp;pF, which restricts practical communication distances to a few meters.Reference designThe reference design, as mentioned above, is a bus with a clock (SCL) and data (SDA) lines with 7-bit addressing. The bus has two roles for nodes: master and slave:Master node &mdash; node that issues the clock and addresses slavesSlave node &mdash; node that receives the clock line and address.The bus is a multi-master bus which means any number of master nodes can be present. Additionally, master and slave roles may be changed between messages (after a STOP is sent).There are four potential modes of operation for a given bus device, although most devices only use a single role and its two modes:master transmit &mdash; master node is sending data to a slavemaster receive &mdash; master node is receiving data from a slaveslave transmit &mdash; slave node is sending data to a masterslave receive &mdash; slave node is receiving data from the masterThe master is initially in master transmit mode by sending a start bit followed by the 7-bit address of the slave it wishes to communicate with, which is finally followed by a single bit representing whether it wishes to write(0) to or read(1) from the slave.If the slave exists on the bus then it will respond with an ACK bit (acknowledge) for that address. The master then continues in either transmit or receive mode (according to the read/write bit it sent), and the slave continues in its complementary mode (receive or transmit, respectively).The address and the data bytes are sent most significant bit first. The start bit is indicated by a high-low transition of SDA with SCL high; the stop bit is indicated by a low-high transition of SDA with SCL high.If the master wishes to write to the slave then it repeatedly sends a byte with the slave sending an ACK bit. (In this situation, the master is in master transmit mode and the slave is in slave receive mode.)If the master wishes to read from the slave then it repeatedly receives a byte from the slave, the master sending an ACK bit after every byte but the last one. (In this situation, the master is in master receive mode and the slave is in slave transmit mode.)The master then ends transmission with a stop bit, or it may send another START bit if it wishes to retain control of the bus for another transfer (a "combined message").Message ProtocolsI²C defines three basic types of message, each of which begins with a START and ends with a STOP:Single message where a master writes data to a slave;Single message where a master reads data from a slave;"Combined" messages, where a master issues at least two reads and/or writes to one or more slaves.In a combined message, each read or write begins with a START and the slave address. After the first START, these are also called "repeated START" bits; repeated START bits are not preceded by STOP bits, which is how slaves know the next transfer is part of the same message.Any given slave will only respond to particular messages, as defined by its product documentation.Pure I²C systems support arbitrary message structures. SMBus is restricted to nine of those structures, such as "read word N" and "write word N", involving a single slave. PMBus extends SMBus with a "Group" protocol, allowing multiple such SMBus transactions to be sent in one combined message. The terminating STOP indicates when those grouped actions should take effect. For example, one PMBus operation might reconfigure three power supplies (using three different I2C slave addresses), and their new configurations would take effect at the same time: when they receive that STOP.With only a few exceptions, neither I²C nor SMBus define message semantics, such as the meaning of data bytes in messages. Message semantics are otherwise product-specific. Those exceptions include messages addressed to the I²C "general call" address (0x00) or to the SMBus "Alert Response Address"; and messages involved in the SMBus "Address Resolution Protocol" (ARP) for dynamic address allocation and management.In practice most slaves adopt request/response control models, where one or more bytes following a write command are treated as a command or address. Those bytes determine how subsequent written bytes are treated and/or how the slave responds on subsequent reads. Most SMBus operations involve single byte commands.Messaging Example: 24c32 EEPROMOne specific example is the 24c32 type EEPROM, which uses two request bytes that are called Address High and Address Low. (Accordingly, these EEPROMs aren't usable by pure SMBus hosts, which only support single byte commands.) These bytes are used to address bytes within the 32 kbit (4 kB) supported by that EEPROM; the same two byte addressing is also used by larger EEPROMs, such as 24c512 ones storing 512 kbits (64 kB).To write to the EEPROM, a single message is used. After the START, the master sends the chip's bus address with the direction bit clear ("write"), then sends the two byte address of data within the EEPROM and then sends data bytes to be written starting at that address, followed by a STOP. When writing multiple bytes, all the bytes must be in the same 32 byte page. While it's busy saving those bytes to memory, the EEPROM won't respond to further I2C requests. (That's another incompatibility with SMBus: SMBus devices must always respond to their bus addresses.)To read starting at a particular address in the EEPROM, a combined message is used. After a START, the master first writes that chip's bus address with the direction bit clear ("write") and then the two bytes of EEPROM data address. It then sends a (repeated) START and the EEPROM's bus address with the direction bit set ("read"). The EEPROM will then respond with the data bytes beginning at the specified EEPROM data address -- a combined message, first a write then a read. The master issues a STOP after the first data byte it NAKs rather than ACKs (when it's read all it wants). The EEPROM increments the address after each data byte transferred; multi-byte reads can retrieve the entire contents of the EEPROM using one combined message.Physical layerAt the physical layer, both SCL & SDA lines are of open-drain design, thus, pull-up resistors are needed. Pulling the line to ground is considered a logical zero while letting the line float is a logical one. This is used as a channel access method. High speed systems (and some others) also add a current source pull up, at least on SCL; this supports faster rise times and higher bus capacitance. Transitions for data bits are always performed while the clock is low, transitions while it is high indicate start and stop bits.When one node is transmitting a logical one (i.e., letting the line float to Vdd) and another transmits a logical zero then the first node can sense this because the line is not in a logical one state &mdash; it is not pulled up to Vdd. When used on SCL, this is called "clock stretching" and gives slaves a flow control mechanism. When used on SDA, this is called arbitration and ensures there is only one transmitter at a time.Clock stretching uses SCLOne of the more significant features of the I²C protocol is clock stretching. An addressed slave device may hold the clock line (SCL) low after receiving (or sending) a bit, indicating that it is not yet ready to process more data. The master that is communicating with the slave will attempt to raise the clock to transfer the next bit, but must verify that the clock line was actually raised. If the slave is clock stretching, the clock line will still be low (because the connections are open-drain). The same is true if a second, slower, master tries to drive the clock at the same time.Clock stretching allows receivers that cannot keep up with a transmitter to control the flow of incoming data. Some masters, such as those found inside custom ASICs may not support clock stretching; often these devices will be labeled as a "two-wire interface" and not strict I²C.To improve its robustness, SMBus places limits on how far clocks may be stretched. Hosts and slaves adhering to those limits can't block access to the bus for more than a short time, which is not a guarantee made by pure I²C systems.Arbitration uses SDAEvery master monitors the bus for start and stop bits, and does not start a message while another master is keeping the bus busy. However, two masters may start transmission at about the same time; in this case, arbitration occurs. Slave transmit mode can also be arbitrated, when a master addresses multiple slaves, but this is less common. In contrast to protocols (such as Ethernet) that use random back-off delays before issuing a retry, I²C has a deterministic arbitration policy. Each transmitter checks the level of the data line (SDA) and compares them with the levels it expects; if they don't match, that transmitter has lost arbitration, and drops out of this protocol interaction.For example, if one master sets a line to 1 (not driving a signal) and a second master sets it to 0 (pull to ground), the result is that the line is low. The first master then observes that the level of the line is different than expected, and concludes that another master is transmitting. The first master to notice such a difference is the one that loses arbitration: it stops driving both signals, waits for a STOP, then tries to reissue its entire message. In the meantime, the other master has not noticed any difference between the expected and actual levels on the lines, and therefore continues transmission. It can do so without problems because so far the level of the lines have been exactly as it expected, which means that no other master has disturbed its transmission.If the two masters are sending a message to two different slaves, the one sending the lower slave address always "wins" arbitration in the address stage. Since the two masters may send messages to the same slave, arbitration must continue into the data stages.Arbitration occurs very rarely, but is necessary for proper multi-master support. As with clock-stretching, not all devices support arbitration. Those that do generally label themselves as supporting "multi-master" communication.SMBus uses arbitration in two additional contexts, both of which are used to pass information asynchronously from slaves to the (single) host. The first context is that hosts must support the "host notify protocol". That is a restricted multi-master mode in which slaves write messages to the reserved "SMBus Host" address (0x08), passing their address and two bytes of data. When two slaves try to notify the host at the same time, one of them will lose arbitration and need to retry. The other context is that pure slave devices which issue the SMBALERT# interrupt need to arbitrate when they reply to requests issued to the reserved "SMBus Alert Response Address" (0x0c), which is a kind of broadcast address. When they successfully reply with their own address, winning an arbitration in "slave transmit" mode, they stop raising that interrupt. In both cases, arbitration applies when the slave address is transmitted..Timing DiagramData transfer is initiated with the START bit (S') when SDA is pulled low while SCL stays high. Then, SDA sets the transferred bit while SCL is low (blue) and the data is sampled (received) when SCL rises (green). When the transfer is complete, a STOP bit ('P) is sent by releasing the data line to allow it to be pulled up while SCL is constantly high.ApplicationsI²C is appropriate for peripherals where simplicity and low manufacturing cost are more important than speed. Common applications of the I²C bus are:Reading configuration data from SPD EEPROMs on SDRAM, DDR SDRAM, DDR2 SDRAM memory sticks (DIMM) and other stacked PC boardsSupporting systems management for PCI cards, through an SMBus 2.0 connection.Accessing NVRAM chips that keep user settings.Accessing low speed DACs.Accessing low speed ADCs.Changing contrast, hue, and color balance settings in monitors (Display Data Channel).Changing sound volume in intelligent speakers.Controlling OLED/LCD displays, like in a cellphone.Reading hardware monitors and diagnostic sensors, like a CPU thermostat and fan speed.Reading real time clocks.Turning on and turning off the power supply of system components.A particular strength of I²C is that a microcontroller can control a network of device chips with just two general-purpose I/O pins and software.Peripherals can also be added to or removed from the I²C bus while the system is running, which makes it ideal for applications that require hot swapping of components.Buses like I²C became popular when computer engineers realized that much of the manufacturing cost of an integrated circuit design results from its package size and pin count. A smaller package also usually weighs less and consumes less power, which is especially important in cellphones and portable computing.Operating System SupportIn Linux, I²C is handled with a specific kernel module for the specific device, and another for the I²C (or SMBus) adapter to which it's connected. Several hundred such drivers exist. There is also an i2c-core module managing the lifecycle of both types of driver, and providing utilities such as emulation of SMBus calls using I²C requests. Details on how to write new I²C drivers can be found in the kernel documentation and in the  header file.NetBSD and OpenBSD also provide an I²C framework, with support for a number of common master controllers and sensors.In Sinclair QDOS and Minerva QL operating systems I²C is supported via a set of extensions provided by TF Services.In AmigaOS the shared library i2c.library of Wilhelm Noeker allows I²C access.eCos supports I²C for several hardware architectures.Development ToolsWhen developing or troubleshooting systems using I2C, visibility at the level of hardware signals can be important.Hardware connectivity Solutions - USB and Serial SupportThere are a number of hardware solutions to give desktop PCs, running Linux, Mac or Windows, I²C master and/or slave capabilities. Most of them are based on Universal Serial Bus (USB) to I²C adaptors. Not all of them require proprietary drivers or APIs.USB to I²C adapter projectI2C ModesOwnerOS SupportedThe 25¢ I²C AdapterMasterOpen SourceMac, Linux (limited hardware support, see documentation)Connii MM 2.0 I2C USB 2.0 Host Adapter Master,MultimastertelosWindows,LabviewAardvark I2C/SPI Host Adapter Master,Multimaster,SlaveTotal PhaseLinux,Windows,MacCAS-1000 I2C/SMbus Analyzer/Exerciser Master,Multimaster,SlaveCorelisWindowsCY3240-I2USBMasterCypress SemiconductorWindowsI2C-Tiny-USB MasterOpen Source + HardwareLinux,Windows,MaciPort/USB I2C Bus Adapter Master/Slave/Std/FastMCCWindows,LinuxNI USB-8451MasterNational InstrumentsWindows, maybe othersTracii XL 2.0 - I2C High Speed Interface for USB 2.0(Multi-)Master/Slave/TracertelosWindows, LabviewU2C-12 USB-I2C/SPI/GPIO Interface AdapterMasterDimaxLinux,Windows,MacUCA93LV 400KHz I2C-Bus Comms Adapter and WINI2C application for USB PortMaster/Slave/MultimasterCalibre UK LtdWindowsUSB-I2CMasterDevantechLinux,Windows,Mac,OpenBSDUSB I2C/IO Interface Board Master,MultimasterDeVaSysWindowsSerial to I²C bridges are also available, for systems with no USB ports.Hardware Protocol AnalyzersI²C Protocol Analyzers are tools which sample an I²C bus and decode the electrical signals to provide a higher level view of the data been transmitted on the bus. Some I²C protocol analyzers are built into oscilloscopes while others are stand-alone devices.I²C AnalyzerI2C SpeedsOwnerOS SupportedBeagle I2C/SPI/MDIO Protocol Analyzer up to 4 MHzTotal PhaseLinux,Windows,MacCAS-1000 I2C/SMbus Analyzer/Exerciser up to 5 MHzCorelisWindowsConnii MM 2.0 - I2C High Speed Interface and Tracer for USB 2.0up to 400 kHztelosWindows, LabviewI2C Bus Monitor Plus up to 400 kHzMCCWindows,LinuxTracii XL 2.0 - I2C High Speed/Analyser/Oscilloscope for USB 2.0up to 3.33 MHztelosWindows, LabviewI2C Negative TestertelosWindowsRevisionsThe original I²C system was created in the early 1980s as a simple internal bus system for building control electronics with various Philips chips.In 1992 the first standardized version was released, which added a new fast mode at 400 kbit/s and a 10-bit addressing mode to increase capacity to 1008 nodes. Version 2.0 from 1998 added high-speed mode at 3.4 Mbit/s with reduced voltage and current requirements that saved power. Version 2.1Revision 2.1 of the I2C specification. from 2000 is a minor cleanup of version 2.0. Version 3Version 03 of the I2C specification. from 2007 adds Fast mode plus (or Fm+) and a device ID mechanism, and is the latest standard.LimitationsThe assignment of slave addresses is one weakness of I²C. Seven bits is too few to prevent address collisions between the many thousands of available devices, and manufacturers rarely dedicate enough pins to configure the full slave address used on a given boardWhen you browse vendor product listings and look at their I2C parts, you will observe that few parts have more than three pins to select I2C addresses, allowing those parts to have at most eight addresses in the typical case that those pins are used to match bits in the I2C address byte.. While some devices can set multiple address bits per pin Maxim's MAX7314 uses a common purely-digital low/high/SDA/SCL scheme to configure four addresses per address pin. TI's UCD9111 uses two ADC channels to select any valid 7-bit address., e.g. by using a spare internal ADC channel to sense one of eight ranges set by an external voltage divider, usually each pin controls one address bit. Manufacturers may provide pins to configure a few low order bits of the address and arbitrarily set the higher order bits to some value based on the model. This limits the number of devices of that model which may be present on the same bus to some low number, typically between two and eight. That partially addresses the issue of address collisisons between different vendors. The addition of ten-bit addresses to I²C hasn't really caught on yetWhen you browse vendor product listings and look at their I2C parts, you'll observe that most of them use 7-bit addresses. Many practitioners have never even seen parts using 10-bit addresses, and many host operating systems don't support them.. Neither has the complex SMBus "ARP" scheme for dynamically assigning addresses (other than for PCI cards with SMBus presence, for which it is required).Automatic bus configuration is a related issue. A given address may be used by a number of different protocol-incompatible devices in various systems, and hardly any device types can be detected at runtime. For example 0x51 may be used by a 24LC02 or 24C32 EEPROM, with incompatible addressing; or by a PCF8563 RTC, which can't reliably be distinguished from either (without changing device state, which might not be allowed). The only reliable configuration mechanisms available to hosts involve out-of-band mechanisms such as tables provided by system firmware which list the available devices. Again, this issue can partially be addressed by ARP in SMBus systems, especially when vendor and product identifiers are used; but that hasn't really caught on. The rev 03 version of the I²C specification adds a device ID mechanism, which at this writing has not had time to catch on either.I²C supports a limited range of speeds. Hosts supporting the multi-megabit speeds are rare. Support for the Fm+ one-megabit speed is more widespread, since its electronics are simple variants of what is used at lower speeds. Many devices don't support the 400 kbit/s speed (in part because SMBus doesn't yet support it). I²C nodes implemented in software (instead of dedicated hardware) may not even support the 100 kbit/s speed; so the whole range defined in the specification is rarely usable. All devices must at least partially support the highest speed used or they may spuriously detect their device address. Devices are allowed to stretch clock cycles to suit their particular needs, which can starve bandwidth needed by faster devices and increase latencies when talking to other device addresses. Bus capacitance also places a limit on the transfer speed, especially when current sources aren't used to increase signal rise times.Because of those limits (address management, bus configuration, speed), few I²C bus segments have even a dozen devices. It's common for systems to have several such segments. One might be dedicated to use with high speed devices, for low latency power management. Another might be used to control a few devices where latency and throughput aren't important issues; yet another segment might be used only to read EEPROM chips describing add-on cards (such as the SPD standard used with DRAM sticks).Derivative TechnologiesI²C is the basis for the ACCESS.bus, the VESA Display Data Channel (DDC) interface, the System Management Bus (SMBus), and the Intelligent Platform Management Bus (IPMB, one of the protocols of IPMI). These implementations have differences in voltage and clock frequency ranges, and may have interrupt lines.TWI (Two Wire Interface) is essentially the same bus implemented on various system-on-chip processors from Atmel and other vendors. avr-libc: Example using the two-wire interface (TWI)&lt;!-- Bot generated title --&gt; Vendors use the name TWI due to trademark licensing issues. (Patents on I²C have now lapsed.)ReferencesSee also1-Wire BusI²SSerial Peripheral Interface Bus (SPI)Serial Presence DetectSystem Management BusExternal linksAdvanced I2C Bus Analysis WebinarDetailed introduction, PrimerI2C BackgroundIntroduction to I²CI²C Bus / Access BusUsing the I²C Bus with LinuxOpenBSD iic(4) manual pageLm-sensors, Linux package which supports sensors using the I²C bus, among others.massmind I²C page Source code, samples and technical information for using I²C with PC, PIC and SX microcontrollers.I²C busSerial buses information pageI²C Bus Technical Overview and Frequently Asked QuestionsThe I²C Faq Version 2.0The Bus Buffer Resource. For 2-wire buses such as I²C, SMBus, PMBus, IPMB &amp; IPMII2C ProtocolCategory:Serial busescs:I²C de:I²C es:I²C fr:I²C ko:I²C it:I²C nl:I²C-bus ja:I²C no:I²C pl:I²C pt:I²C ru:I²C su:I2C fi:I²C sv:I²C vi:I²C zh:I2C