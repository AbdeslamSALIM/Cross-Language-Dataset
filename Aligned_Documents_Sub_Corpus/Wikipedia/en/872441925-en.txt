In computer science, reflection is the process by which a computer program can observe and modify its own structure and behavior. The programming paradigm driven by reflection is called reflective programming.In most modern computer architectures, program instructions are stored as data - hence the distinction between instruction and data is merely a matter of how the information is treated by the computer and programming language. Normally, 'instructions' are 'executed' and 'data' is 'processed'; however, in some languages, programs can also treat instructions as data and therefore make reflective modifications. Reflection is most commonly used in high-level virtual machine programming languages like Smalltalk and scripting languages, and less commonly used in manifestly typed and/or statically typed programming languages such as Java and C.Reflection-oriented programmingReflection-oriented programming, or reflective programming, is a functional extension to the object-oriented programming paradigm. Reflection-oriented programming includes self-examination, self-modification, and self-replication. However, the emphasis of the reflection-oriented paradigm is dynamic program modification, which can be determined and executed at runtime. Some imperative approaches, such as procedural and object-oriented programming paradigms, specify that there is an exact predetermined sequence of operations with which to process data. The reflection-oriented programming paradigm, however, adds that program instructions can be modified dynamically at runtime and invoked in their modified state. That is, the program architecture itself can be decided at runtime based upon the data, services, and specific operations that are applicable at runtime.Programming sequences can be classified in one of two ways, atomic or compound. Atomic operations are those that can be viewed as completing in a single, logical step, such as the addition of two numbers. Compound operations are those that require a series of multiple atomic operations.A compound statement, in classic procedural or object-oriented programming, can lose its structure once it is compiled. The reflective programming paradigm introduces the concept of ''meta-information'', which keeps knowledge of program structure. Meta-information stores information such as the name of the contained methods, the name of the class, the name of parent classes, and/or what the compound statement is supposed to do. Using this stored information, as an object is consumed (processed), it can be reflected upon to find out the operations that it supports. The operation that issues in the required state via the desired state transition can be chosen at run-time without hard-coding it.UsesReflection can be used for observing and/or modifying program execution at runtime. A reflection-oriented program component can monitor the execution of an enclosure of code and can modify itself according to a desired goal related to that enclosure. This is typically accomplished by dynamically assigning program code at runtime.Reflection can also be used to adapt a given program to different situations dynamically. For example, consider an application that uses two different classes X and Y interchangeably to perform similar operations. Without reflection-oriented programming, the application might be hard-coded to call method names of class X and class Y. However, using the reflection-oriented programming paradigm, the application could be designed and written to utilize reflection in order to invoke methods in classes X and Y without hard-coding method names. Reflection-oriented programming almost always requires additional knowledge, framework, relational mapping, and object relevance in order to take advantage of more generic code execution. Hard-coding can be avoided to the extent that reflection-oriented programming is used.Reflection is also a key strategy for metaprogramming.ImplementationA language supporting reflection provides a number of features available at runtime that would otherwise be very obscure or impossible to accomplish in a lower-level language. Some of these features are the abilities to:Discover and modify source code constructions (such as code blocks, classes, methods, protocols, etc.) as a first-class object at runtime.Convert a string matching the symbolic name of a class or function into a reference to or invocation of that class or function.Evaluate a string as if it were a source code statement at runtime.These features can be implemented in different ways. In MOO, reflection forms a natural part of everyday programming idiom. When verbs (methods) are called, various variables such as verb (the name of the verb being called) and this (the object on which the verb is called) are populated to give the context of the call. Security is typically managed by accessing the caller stack programmatically: Since callers() is a list of the methods by which the current verb was eventually called, performing tests on callers()1 (the command invoked by the original user) allows the verb to protect itself against unauthorised use.Compiled languages rely on their runtime system to provide information about the source code. A compiled Objective-C executable, for example, records the names of all methods in a block of the executable, providing a table to correspond these with the underlying methods (or selectors for these methods) compiled into the program. In a compiled language that supports runtime creation of functions, such as Common Lisp, the runtime environment must include a compiler or an interpreter.Reflection can be implemented for languages not having built-in reflection facilities by using a program transformation system to define automated source code changes..ExamplesActionScriptHere is an equivalent example in ActionScript:  // Without reflection var foo:Foo = new Foo(); foo.hello();// With reflection var ClassReference:Class = flash.utils.getDefinitionByName("Foo") as Class; var instance:Object = new ClassReference(); instance.hello();  Even with an import statement on Foo, the method call to getDefinitionByName will break without an internal reference to the class. This is because runtime compilation of source is not currently supported. To get around this, you have to have at least one instantiation of the class type in your code for the above to work. So in your class definition you declare a variable of the custom type you want to use:  var customType : Foo;  So for the idea of dynamically creating a set of views in Flex 2 using these methods in conjunction with an xml file that may hold the names of the views you want to use, in order for that to work, you will have to instantiate a variable of each type of view that you want to utilize.Note:The above is not strictly true. Without a reference to the class somewhere in the source, the compiler will simply ignore the class and not include it in the compiled binary. Instantiating a variable will ensure that the compiler includes the class, but it is completely unnecessary and undesirable due to memory issues. Use the following instead:  Foo; C#Here is an equivalent example in C#:  //Without reflection Foo foo = new Foo(); foo.Hello();//With reflection Type t = Assembly.GetCallingAssembly().GetType("FooNamespace.Foo"); t.InvokeMember("Hello", BindingFlags.InvokeMethod, null, Activator.CreateInstance(t), null); This next example demonstrates the use of advanced features of reflection. It loads an assembly (which can be thought of as a class library) dynamically and uses reflection to find the methods that take no parameters and figure out whether it was recently modified or not. To decide whether a method was recently modified or not, it uses a custom attribute RecentlyModified which the developer tags the methods with. Presence of the attribute indicates it was recently modified. An attribute is itself implemented as a class, that derives from the Attribute class.The program loads the assembly dynamically at runtime, and checks that the assembly supports the RecentlyModified attribute. This check is facilitated by using another custom attribute on the entire assembly: SupportsRecentlyModified. If it is supported, names of all the methods are then retrieved. For each method, objects representing all its parameters as well as the objects representing the RecentlyAttribute are retrieved. If the attribute retrieval succeeds and the parameter retrieval fails (indicating presence of the attribute but absence of any parameters), a match has been found.Definition of the custom attributes: //RecentlyModified: Applicable only to methods. //SupportsRecentlyModified: Applicable to the entire assembly.AllowMultiple=false) class RecentlyModifiedAttribute : Attribute AllowMultiple=false) class SupportsRecentlyModifiedAttribute : Attribute  Implementation of the method filter: static void Main(string[] args) &quot;, method.Name);
               
        C++Although the language itself does not provide any support for reflection, there are some attempts based on templates, RTTI information, using debug information provided by the compiler, or even patching the GNU compiler to provide extra information.Common LispHere is an equivalent example in Common Lisp: Without reflection(hello)With reflection(funcall (read-from-string "hello"))or(funcall (symbol-function (intern "hello")))  However, this works only for symbols in topmost lexical environment (or dynamic one). A better example, using CLOS, is: Method hello is called on instance of class foo.(hello (make-instance 'foo))or(hello (make-instance (find-class 'foo))  This code is equivalent to Java's one. Common Lisp, like Scheme, is able to transform lists into functions or procedures. This is the source of the Lisp macro ability to change the code behavior (including from other macros) during (and after) compilation.CurlHere is an equivalent example in Curl: || Without reflection
 let foo1:Foo = 
  || Using runtime 'any' calls
 let foo2:any = 
  || Using reflection
 let foo3:any = 
 
  case class:ClassType do
     then
       
    
     All three of these examples instantiate an instance of the Foo class and invoke its hello method. The first, resolves the lookup at compile-time and will generate the most efficient code for invoking the method at runtime. The second, invokes the method through an 'any' variable which will do both the lookup and invocation at runtime, which is much less efficient. The third, uses the reflection interface to lookup the method in the Foo class and invoke it, which is also much less efficient than the first example.Delphi’s dialect of Object PascalAlthough the language itself does not provide explicit support for reflection, this can be done by making use of the runtime type information (RTTI) generated by the compiler, as the following example illustrates. program Reflections;  uses Classes, SysUtils;type TBase = class(TPersistent)
   procedure Common; virtual; abstract;
 end;  TDescendentClass = class of TBase; TSpecialMethod = procedure (Args: array of const) of object; TDescendent1 = class(TBase)
   procedure Common; override;
 published
   
   procedure Special(Values: array of const);
 end; TDescendent2 = class(TBase)
   procedure Common; override;
 end;procedure TDescendent1.Common; begin Writeln('TDescendent1.Common called.');end;procedure TDescendent1.Special(Values: array of const); var I: Integer;begin  Writeln('TDescendent1.Special called with ');
 for I := 0 to High(Values) do 
   with Values[I] do begin
     Write(#9);
     case VType of 
       vtInteger: Writeln('an integer');
       vtBoolean: Writeln('a boolean');
       vtChar: Writeln('a char');
       vtString, vtAnsiString, vtPChar: Writeln('a string');
       vtObject: Writeln('an object');
       vtClass: Writeln('a class reference');
     else
       Writeln('something else (VType = ', VType, ')');
     end;
   end;end;procedure TDescendent2.Common; begin Writeln('TDescendent2.Common called.');end;procedure ClassTest(AClass: TDescendentClass); var Obj: TBase;
 Special: TSpecialMethod;begin Obj := AClass.Create;
 try
   Obj.Common;
   with TMethod(Special) do begin
     Code := Obj.MethodAddress('Special');
     Data := Obj;
   end;
   if Assigned(Special) then 
     Special([1234, 'str', Char('x'), Obj, AClass, False, 2.2]);
 finally
   Obj.Free;
 end;end;var ObjClass: TDescendentClass;
 I: Integer;begin RegisterClasses([TDescendent1, TDescendent2]); for I := 1 to 2 do begin
   ObjClass := TDescendentClass(GetClass('TDescendent' + IntToStr(I)));
   if Assigned(ObjClass) then ClassTest(ObjClass);
 end; UnregisterClasses([TDescendent1, TDescendent2]);end. Even more flexible reflections can be achieved by using a runtime compilation engine, like PascalScript.ECMAScript (JavaScript)Here is an equivalent example in ECMAScript:  // Without reflection new Foo().hello()// With reflection// assuming that Foo resides in this new this'Foo'()'hello'()// or without assumption new (eval('Foo'))()'hello'() IoHere is an equivalent example in Io:// Without reflection
hello
&lt;br /&gt;
// With reflection
doString(&quot;hello&quot;)JavaThe following is an example in Java using the Java package . Consider two pieces of code  // Without reflection Foo foo = new Foo(); foo.hello();// With reflection Class cls = Class.forName("Foo"); Object foo = cls.newInstance(); Method method = cls.getMethod("hello", null); method.invoke(foo, null);  Both code fragments create an instance of a class Foo and call its hello() method. The difference is that, in the first fragment, the names of the class and method are hard-coded; it is not possible to use a class of another name. In the second fragment, the names of the class and method can easily be made to vary at runtime. The downside is that the second version is harder to read, and is not protected by compile-time syntax and semantic checking. For example, if no class Foo exists, an error will be generated at compile time for the first version. The equivalent error will only be generated at run time for the second version.LuaHere's an equivalent example in Lua:''-- Without reflection''
'''hello'''()
&lt;br /&gt;
''-- With reflection''
'''loadstring'''(&quot;hello()&quot;)()The function loadstring compiles the chunk and returns it as a parameterless function.If hello is a global function, it can be accessed by using the table _G:''-- Using the table _G, which holds all global variables''
_G[&quot;hello&quot;]()MOOHere is an equivalent example in MOO:&quot;without reflection&quot;;
foo:hello();&quot;with partial reflection&quot;;
foo:(&quot;hello&quot;)();Objective-CHere is an equivalent example in Objective-C (using Cocoa runtime):  // Without reflection [[alloc init] hello];// With reflection Class aClass = NSClassFromString(@"Foo"); SEL aSelector = NSSelectorFromString(@"hello"); // or @selector(hello) if the method                                               // name is known at compile time[[alloc init] performSelector:aSelector]; PerlHere is an equivalent example in Perl: without reflectionmy $foo = Foo-new(); $foo-hello();with reflectionmy $class = "Foo"; my $method = "hello"; my $object = $class-new(); $object-$method(); PHPHere is an equivalent example in PHP.This is the non-reflective way to invoke Foo::hello:  $Foo = new Foo(); $Foo-hello(); Using reflection the class and method are retrieved as reflection objects and then used to create a new instance and invoke the method.  $f = new ReflectionClass("Foo"); $m = $f-GetMethod("hello"); $m-invoke( $f-newInstance() ); PythonHere is an equivalent example from the Python shell. Reflection is an important part of Python and there are several ways it can be achieved, many of which do not include the use of the eval() function and its attendant security risks:   # Class definition  class Foo(object): ... def Hello(self): ... print "Hi" ...  # Instantiation  foo = Foo()  # Normal call  foo.Hello() Hi  # Evaluate a string in the context of the global namespace  eval("foo.Hello()", globals()) Hi  # Interpret distinct instance & method names from strings  instancename = 'foo'  methodname = 'Hello'  instance = globals()instancename  method = getattr(instance , methodname)  method() Hi  # or get a method from class not from object  classfoo = type(instance)  unboundmethod= getattr(classfoo , methodname)  unboundmethod(instance) Hi REBOLHere is an example in REBOL:; Without reflection
hello
&lt;br /&gt;
; With reflection
do [hello]This works because the language is fundamentally reflective, processing via symbols, not strings.To illustrate that the above example is reflective (not simply evaluation of a code block) you can write:if 'hello = first [hello] [print &quot;this is true&quot;]RubyHere is an equivalent example in Ruby: without reflectionFoo.new.hellowith reflectionObject.const_get(:Foo).new.send(:hello) SchemeHere is an equivalent example in Scheme: Without reflection(hello)With reflection(eval '(hello))With reflection via string using string I/O ports(eval (read (open-input-string "(hello)"))) SmalltalkHere is an equivalent example in Smalltalk: "Without reflection" Foo new hello"With reflection" (Compiler evaluate: 'Foo') new perform: #hello The class name and the method name will often be stored in variables and in practice runtime checks need to be made to ensure that it is safe to perform the operations: "With reflection"| x y className methodName |className := 'Foo'. methodName := 'hello'.x := (Compiler evaluate: className).(x isKindOf: Class) ifTrue: [   y := x new.   (y respondsTo: methodName asSymbol) ifTrue: [
       y perform: methodName asSymbol
   ]] Smalltalk also makes use of blocks of compiled code that are passed around as objects. This means that generalised frameworks can be given variations in behavior for them to execute. Blocks allow delayed and conditional execution. They can be parameterised. (Blocks are implemented by the class BlockClosure). X := [ :op | 99 perform: op with: 1].  &quot;.....then later we can execute either of:&quot;X value: #+ "which gives 100, or" X value: #- "which gives 98." Windows PowerShellHere is an equivalent example in Windows PowerShell:# without reflection
$foo = new-object Foo
$foo.hello()# with reflection
$class  = 'Foo'
$method = 'hello'
$object = new-object $class
$object.$method.Invoke()See alsoType introspectionSelf-modifying codeProgramming paradigmsList of reflective programming languages and platformsReferencesJonathan M. Sobel and Daniel P. Friedman. [http://www.cs.indiana.edu/~jsobel/rop.html An Introduction to Reflection-Oriented Programming] (1996), Indiana University.==Further reading==Ira R. Forman and Nate Forman, Java Reflection in Action (2005), ISBN 1932394184Ira R. Forman and Scott Danforth, Putting Metaclasses to Work (1999), ISBN 0-201-43305-2External linksReflection in logic, functional and object-oriented programming: a Short Comparative Study (Citeseer page).An Introduction to Reflection-Oriented ProgrammingReflection in C++/CLI for .NetReflection for C++Aspects of Reflection in C++LibReflection: A reflection library for C++.A library to provide full reflection for C++ through template metaprogramming techniques.A C++ reflection-based data dictionaryBrian Foote's pages on Reflection in SmalltalkJava Reflection Tutorial from Sun MicrosystemsJava Reflection Tutorial By Jakob Jenkov Category:Programming paradigmsca:Reflexió (informàtica) de:Reflexion (Programmierung) es:Reflexión (informática) fr:Réflexion (informatique) ko:반영 (컴퓨터) it:Riflessione (informatica) lt:Refleksija (programavimas) nl:Reflectie (informatica) ja:リフレクション (情報工学) pl:Mechanizm refleksji pt:Reflexão (programação) ru:Отражение (программирование) vi:Reflection (khoa học máy tính) zh:反射 (计算机科学)