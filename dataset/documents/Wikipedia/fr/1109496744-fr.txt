 On désigne par algorithmique l’ensemble des activités logiques qui relèvent des algorithmes ; en particulier, en informatique, cette discipline désigne l'ensemble des règles et des techniques qui sont impliquées dans la définition et la conception des algorithmes. Le mot vient du nom du mathématicien Al Khuwarizmi (latinisé au Moyen Âge en ), qui, au  écrivit le premier ouvrage systématique sur la solution des équations linéaires et quadratiques. Dans le cas général, l’algorithmique s’effectue au moyen de calculs.Il est parfois fait usage du mot algorithmie, bien que ce dernier ne figure pas dans la plupart des dictionnaires.DéfinitionUn algorithme est un processus systématique de résolution, par le calcul, d'un problème permettant de présenter les étapes vers le résultat à une autre personne physique (un autre humain) ou virtuelle (un calculateur). En d'autres termes, un algorithme est un énoncé d’une suite d’opérations permettant de donner la réponse à un problème. Si ces opérations s’exécutent en séquence, on parle d’algorithme séquentiel. Si les opérations s’exécutent sur plusieurs processeurs en parallèle, on parle d’algorithme parallèle. Si les tâches s’exécutent sur un réseau de processeurs on parle d’algorithme réparti ou distribué.HistoriqueAntiquitéLes algorithmes dont on a retrouvé des descriptions exhaustives ont été utilisés dès l’époque des Babyloniens, pour des calculs concernant le commerce et les impôts.L’algorithme le plus célèbre est celui qui se trouve dans le livre&nbsp;7 des Éléments d'Euclide. Il permet de trouver le plus grand diviseur commun, ou PGCD, de deux nombres. Un point particulièrement remarquable est qu’il contient explicitement une itération et que les propositions&nbsp;1 et 2 démontrent (maladroitement pour nos contemporains) sa convergence.Étude systématiqueL’algorithmique a été systématisée par le mathématicien perse Al Khuwarizmi (né vers 780 - mort vers 850), auteur d’un ouvrage (souvent traduit par L’algèbre et le balancement) qui décrit des méthodes de calculs algébriques (en plus d'introduire le zéro des Indiens).Le savant arabe Averroès (1126-1198) évoque une méthode de raisonnement où la thèse s’affine étape par étape (itérativement) jusqu’à une certaine convergence et ceci conformément au déroulement d’un algorithme. À la même époque, au , le moine Adelard de Bath a introduit le terme latin de  (par référence au nom de Al Khuwarizmi). Ce mot donne algorithme en français en 1554.Au , on pourrait entrevoir une certaine allusion à la méthode algorithmique chez René Descartes dans la méthode générale proposée par le Discours de la méthode (1637), notamment quand, en sa deuxième partie, le logicien français propose de  Sans évoquer explicitement les concepts de boucle ou d’itération, l’approche de Descartes prédispose la logique à accueillir le concept de programme, mot qui naît en français en 1677.L’utilisation du terme algorithme a été remarquable chez Ada Lovelace, fille de Lord Byron et assistante de Charles Babbage (1792-1871).VocabulaireLe substantif algorithmique désigne la méthode utilisant des algorithmes. Le terme est également employé comme adjectif.Un algorithme énonce une résolution sous la forme d’une série d’opérations à effectuer. La mise en œuvre de l’algorithme consiste en l’écriture de ces opérations dans un langage de programmation et constitue alors la brique de base d’un programme informatique.Les informaticiens utilisent fréquemment l’anglicisme implémentation pour désigner cette mise en œuvre. L’écriture en langage informatique est aussi fréquemment désignée par le terme « codage », qui n’a ici aucun rapport avec la cryptographie, mais qui se réfère au terme « code source » pour désigner le texte, en langage de programmation, constituant le programme. L’algorithme devra être plus ou moins détaillé selon le niveau d’abstraction du langage utilisé ; autrement dit, une recette de cuisine doit être plus ou moins détaillée en fonction de l’expérience du cuisinier.Exemples d’algorithmesIl existe un certain nombre d’algorithmes classiques, utilisés pour résoudre des problèmes ou plus simplement pour illustrer des méthodes de programmation. On se référera aux articles suivants pour de plus amples détails :tours de Hanoï, problème célèbre illustrant la programmation récursive ;algorithme de tri, ou comment trier un ensemble de nombres le plus rapidement possible ;huit dames, placer huit dames sur un échiquier sans qu’elles puissent se prendre entre elles ;algorithme récursif, quelques présentations d’algorithmes récursifs simples ;algorithme du simplexe, qui minimise une fonction linéaire de variables réelles soumises à des contraintes linéaires.Fraction continue d'un nombre quadratique, permettant d'extraire une racine carrée.Complexité algorithmiqueLes principales notions mathématiques dans le calcul du coût d’un algorithme précis sont les notions de domination (notée O(f(n)), « grand o »), où f'' est une fonction mathématique de ''n, variable désignant la quantité d’informations (en bits, en nombre d’enregistrements, etc.) manipulée dans l’algorithme. En algorithmique on trouve souvent des complexités du type :NotationType de complexitéO(1)complexité constante (indépendante de la taille de la donnée)O(log(n))complexité logarithmiqueO(n)complexité linéaireO(n log(n))complexité quasi-linéaireO(n^)complexité quadratiqueO(n^)complexité cubiqueO(n^p)complexité polynomialeO(n^)complexité quasi-polynomialeO(2^)complexité exponentielleO(n!)complexité factorielleSans entrer dans les détails mathématiques, le calcul de l’efficacité d’un algorithme (sa complexité algorithmique), consiste en la recherche de deux quantités importantes. La première quantité est l’évolution du nombre d’instructions de base en fonction de la quantité de données à traiter (par exemple, pour un algorithme de tri, il s'agit du nombre de données à trier), que l’on privilégiera sur le temps d'exécution mesuré en secondes (car ce dernier dépend de la machine sur laquelle l'algorithme s'exécute). La seconde quantité estimée est la quantité de mémoire nécessaire pour effectuer les calculs. Baser le calcul de la complexité d’un algorithme sur le temps ou la quantité effective de mémoire qu’un ordinateur particulier prend pour effectuer ledit algorithme ne permet pas de prendre en compte la structure interne de l’algorithme, ni la particularité de l’ordinateur : selon sa charge de travail, la vitesse de son processeur, la vitesse d’accès aux données, l’exécution de l’algorithme (qui peut faire intervenir le hasard) ou son organisation de la mémoire, le temps d’exécution et la quantité de mémoire ne seront pas les mêmes.Il existe également un autre aspect de l'évaluation de l'efficacité d'un algorithme : les performances en moyenne de cet algorithme. Elle suppose d'avoir un modèle de la répartition des données de l'algorithme, tandis que la mise en œuvre des techniques d'analyse implique des méthodes assez fines de combinatoire et d'évaluation asymptotique, utilisant en particulier les séries génératrices et des méthodes avancées d'analyse complexe. L'ensemble de ces méthodes sont regroupées sous le nom de combinatoire analytique.On trouvera dans l’article sur la théorie de la complexité d’autres évaluations de la complexité qui vont en général au delà des valeurs proposées ci-dessus et qui répartissent les problèmes (plutôt que les algorithmes) en classes de complexité.Quelques indications sur l’efficacité des algorithmesSouvent, l’efficacité d’un algorithme n’est connue que de manière asymptotique, c’est-à-dire pour de grandes valeurs du paramètre n. Lorsque ce paramètre est suffisamment petit, un algorithme de complexité supérieure peut en pratique être plus efficace. Ainsi, pour trier un tableau de 30&nbsp;lignes (c’est un paramètre de petite taille), il est inutile d’utiliser un algorithme évolué comme le Tri rapide (l’un des algorithmes de tri les plus efficaces en moyenne) : l’algorithme de tri le plus trivial sera suffisamment efficace.Entre deux algorithmes dont la complexité est identique, on cherchera à utiliser celui dont l’occupation mémoire est la plus faible. L’analyse de la complexité algorithmique peut également servir à évaluer l’occupation mémoire d’un algorithme. Enfin, le choix d’un algorithme plutôt qu’un autre doit se faire en fonction des données que l’on s’attend à lui fournir en entrée. Ainsi, le  (ou tri rapide), lorsque l’on choisit le premier élément comme pivot, se comporte de façon désastreuse si on l’applique à une liste de valeurs déjà triée. Il n’est donc pas judicieux de l’utiliser si on prévoit que le programme recevra en entrée des listes déjà presque triées.Un autre paramètre à prendre en compte est la localité de l’algorithme. Par exemple pour un système à mémoire virtuelle qui dispose de peu de mémoire (par rapport au nombre de données à traiter), le Tri rapide sera normalement plus efficace que le Tri par tas car le premier ne passe qu’une seule fois sur chaque élément de la mémoire tandis que le second accède à la mémoire de manière discontinue (ce qui augmente le risque de ).Enfin, il existe certains algorithmes dont la complexité est dite amortie. Cela signifie que, pour certaines exécutions de l’algorithme (cas marginaux), la complexité de l’algorithme sera très supérieure au cas moyen. Bien sûr, on n’utilise la notion de complexité amortie que dans les cas où cette réaction est très marginale.Les heuristiquesPour certains problèmes, les algorithmes ont une complexité beaucoup trop grande pour obtenir un résultat en temps raisonnable, même si l’on pouvait utiliser une puissance de calcul phénoménale. On est donc amené à rechercher une solution la plus proche possible d’une solution optimale en procédant par essais successifs. Puisque toutes les combinaisons ne peuvent être essayées, certains choix stratégiques doivent être faits. Ces choix, généralement très dépendants du problème traité, constituent ce qu’on appelle une heuristique. Le but d’une heuristique n'est donc pas d'essayer toutes les combinaisons possibles afin de trouver celle répondant au problème, mais de trouver une solution approchée convenable (qui peut être exacte dans certains cas) dans un temps raisonnable. C’est ainsi que les programmes de jeu d’échecs, de jeu de go (pour ne citer que ceux-là) font appel de manière très fréquente à des heuristiques qui modélisent l’expérience d’un joueur. Certains logiciels antivirus se basent également sur des heuristiques pour reconnaître des virus informatiques non répertoriés dans leur base, en s’appuyant sur des ressemblances avec des virus connus.ApplicationsAlgorithme génétique en informatique décisionnelleAllocation de mémoire et ramasse-miettesCryptologie et compression de donnéesInformatique musicaleStructure de données, Algorithmes de tri et Recherche dichotomiqueVoir aussi  Articles connexesAl-KhuwarizmiAlgorithme récursifAlgorithme répartiListe des algorithmesMétaheuristiqueRecherche opérationnelleStructure de contrôleLiens externesLes Wikilivres sont une source d’information Wiki pour les langages de programmations et l’algorithmique Catégorie:Algorithmiqueaf:Algoritme an:Algorismo ar:خوارزمية ast:Algoritmu az:Alqoritm be:Алгарытм be-x-old:Альгарытм bg:Алгоритъм bn:অ্যালগোরিদম bs:Algoritam ca:Algorisme cs:Algoritmus da:Algoritme de:Algorithmus el:Αλγόριθμος en:Algorithm eo:Algoritmo es:Algoritmo et:Algoritm fa:الگوریتم fi:Algoritmi gl:Algoritmo he:אלגוריתם hi:अल्गोरिद्म hr:Algoritam hu:Algoritmus ia:Algorithmo id:Algoritma io:Algoritmo is:Reiknirit it:Algoritmo ja:アルゴリズム ka:ალგორითმი kaa:Algoritm ko:알고리즘 ku:Algorîtma lb:Algorithmus lt:Algoritmas lv:Algoritms mk:Алгоритам mn:Алгоритм ms:Algoritma nl:Algoritme nn:Algoritme no:Algoritme pl:Algorytm pt:Algoritmo ro:Algoritm ru:Алгоритм sah:Алгоритм sd:الخوارزمي sh:Algoritam simple:Algorithm sk:Algoritmus sl:Algoritem sq:Algoritmi sr:Алгоритам su:Algoritma sv:Algoritm ta:ஆல்கரிதம் te:అల్గారిథం tg:Алгоритм th:ขั้นตอนวิธี tl:Algoritmo tr:Algoritma uk:Алгоритм vi:Thuật toán wa:Algorisse yi:אלגאריטם zh:算法 zh-yue:演算法