OpenGL (Open G'raphics '''L'ibrary) es una especificación estándar que define una API multilenguaje y multiplataforma para escribir aplicaciones que produzcan gráficos 2D y 3D. La interfaz consiste en más de 250 funciones diferentes que pueden usarse para dibujar escenas tridimensionales complejas a partir de primitivas geométricas simples, tales como puntos, líneas y triángulos. Fue desarrollada originalmente por Silicon Graphics Inc. ('''SGI) en 1992 y se usa ampliamente en CAD, realidad virtual, representación científica, visualización de información y simulación de vuelo. También se usa en desarrollo de videojuegos, donde compite con Direct3D en plataformas Microsoft Windows.EspecificaciónFundamentalmente OpenGL es una especificación, es decir, un documento que describe un conjunto de funciones y el comportamiento exacto que deben tener. Partiendo de ella, los fabricantes de hardware crean implementaciones, que son bibliotecas de funciones que se ajustan a los requisitos de la especificación, utilizando aceleración hardware cuando es posible. Dichas implementaciones deben superar unos tests de conformidad para que sus fabricantes puedan calificar su implementación como conforme a OpenGL y para poder usar el logotipo oficial de OpenGL.Hay implementaciones eficientes de OpenGL para Mac OS, Microsoft Windows, Linux, varias plataformas Unix y PlayStation 3. Existen también varias implementaciones en software que permiten ejecutar aplicaciones que dependen de OpenGL sin soporte de aceleración hardware. Es destacable la biblioteca de software libre / código abierto Mesa 3D, una API de gráficos basada sin aceleración hardware y completamente compatible con OpenGL. Sin embargo, para evitar los costes de la licencia requerida para ser denominada formalmente como una implementación de OpenGL, afirma ser simplemente una API muy similar.La especificación OpenGL era revisada por el OpenGL Architecture Review Board (ARB), fundado en 1992. El ARB estaba formado por un conjunto de empresas interesadas en la creación de una API consistente y ampliamente disponible. Microsoft, uno de los miembros fundadores, abandonó el proyecto en 2003.El 21 de septiembre de 2006 se anunció que el control de OpenGL pasaría del ARB al Grupo Khronos. Con ello se intentaba mejorar el marketing de OpenGL y eliminar las barreras entre el desarrollo de OpenGL y OpenGL ES. ARB se convirtió dentro de Khronos en el OpenGL ARB Working Group. El subgrupo de Khronos que gestiona la especificación de OpenGL se denomina OpenGL ARB Working Group. Para una relación de los miembros que componen el OpenGL ARB Working Group, véase el apartado Miembros del Grupo Khronos. El gran número de empresas con variados intereses que han pasado tanto por el antiguo ARB como por el grupo actual han hecho de OpenGL una API de propósito general con un amplio rango de posibilidades.Mark Segal y Kurt Akeley fueron los autores de la especificación original de OpenGL. Chris Frazier fue el editor de la versión 1.1. Jon Leech ha editado las versiones desde 1.2 hasta la presente 3.0.DiseñoOpenGL tiene dos propósitos esenciales:Ocultar la complejidad de la interfaz con las diferentes tarjetas gráficas, presentando al programador una API única y uniforme.Ocultar las diferentes capacidades de las diversas plataformas hardware, requiriendo que todas las implementaciones soporten la funcionalidad completa de OpenGL (utilizando emulación software si fuese necesario).El funcionamiento básico de OpenGL consiste en aceptar primitivas tales como puntos, líneas y polígonos, y convertirlas en píxeles. Este proceso es realizado por una pipeline gráfica conocida como la Máquina de estados de OpenGL. La mayor parte de los comandos de OpenGL o bien emiten primitivas a la pipeline gráfica o bien configuran cómo la pipeline procesa dichas primitivas. Hasta la aparición de la versión 2.0 cada etapa de la pipeline ejecutaba una función prefijada, resultando poco configurable. A partir de la versión 2.0 algunas etapas son programables usando un lenguaje de programación llamado GLSL.OpenGL es una API basada en procedimientos de bajo nivel que requiere que el programador dicte los pasos exactos necesarios para renderizar una escena. Esto contrasta con las APIs descriptivas, donde un programador sólo debe describir la escena y puede dejar que la biblioteca controle los detalles para representarla. El diseño de bajo nivel de OpenGL requiere que los programadores conozcan en profundidad la pipeline gráfica, a cambio de darles libertad para implementar algoritmos gráficos novedosos.OpenGL ha influido en el desarrollo de las tarjetas gráficas, promocionando un nivel básico de funcionalidad que actualmente es común en el hardware comercial; algunas de esas contribuciones son:Primitivas básicas de puntos, líneas y polígonos rasterizados.thumb|right|430px|Proceso en la pipeline de gráficosUna pipeline de transformación e iluminación.Z-buffering.Mapeado de texturas.Alpha blending.Una descripción somera del proceso en la pipeline gráfica podría ser:Evaluación, si procede, de las funciones polinomiales que definen ciertas entradas, como las superficies NURBS, aproximando curvas y la geometría de la superficie.Operaciones por vértices, transformándolos, iluminándolos según su material y recortando partes no visibles de la escena para producir un volumen de visión.Rasterización, o conversión de la información previa en píxeles. Los polígonos son representados con el color adecuado mediante algoritmos de interpolación.Operaciones por fragmentos o segmentos, como actualizaciones según valores venideros o ya almacenados de profundidad y de combinaciones de colores, entre otros.Por último, los fragmentos son volcados en el Frame buffer.Muchas tarjetas gráficas actuales proporcionan una funcionalidad superior a la básica aquí expuesta, pero las nuevas características generalmente son mejoras de esta pipeline básica más que cambios revolucionarios de ella.EjemploPrimero, limpiamos el buffer de color para empezar en un canvas negro: glClear( GL_COLOR_BUFFER_BIT ); Se establece la matriz modelview, que controla la posición de la cámara respecto a las primitivas que renderizamos. La retrasamos 3 unidades en el eje Z, dejándola apuntando hacia el origen: glMatrixMode( GL_MODELVIEW ); /* Los comandos para matriz modificarán modelview */ glLoadIdentity(); /* Inicializar modelview */ glTranslatef( 0, 0, -3 ); /* Desplazar 3 unidades en el eje Z */  La matriz projection controla la perspectiva aplicada a las primitivas; se utiliza de forma similar a la anterior: glMatrixMode( GL_PROJECTION ); /* Los comandos para matriz modificarán projection */ glLoadIdentity(); /* Inicializar projection */ glFrustum( -1, 1, -1, 1, 1, 1000 ); /* Aplicar una proyección en perspectiva */ Por último, se dibuja un polígono (un cuadrado verde orientado en el plano XY): glBegin( GL_POLYGON ); /* Inicio de polígono */ glColor3f( 0, 1, 0 ); /* Establecer color actual a verde */ glVertex3f( -1, -1, 0 ); /* Establecer un vértice */ glVertex3f( -1, 1, 0 ); /* Establecer un vértice */ glVertex3f( 1, 1, 0 ); /* Establecer un vértice */ glVertex3f( 1, -1, 0 ); /* Establecer un vértice */ glEnd(); /* Fin de polígono */ HistoriaEn los años 1980 el desarrollo de software que fuese compatible con un amplio rango de hardware gráfico era un verdadero reto para los desarrolladores. Había que tratar con interfaces muy diferentes y escribir drivers específicos para cada tipo de hardware, resultando muy costoso; por ello, se subcontrataban equipos de programadores para agilizar el desarrollo. Dado que cada equipo trabajaba por separado en sus interfaces, se producía mucho código redundante. Además, era un proceso caro, por lo que varios grupos innovadores aceptaron el reto de encontrar un método mejor.Al principio de los años 1990 SGI era un grupo de referencia en gráficos 3D para estaciones de trabajo. Suya era la API IRIS GL, considerada puntera en el campo y estándar de facto, llegando a eclipsar a PHIGS, basada en estándares abiertos. IRIS GL se consideraba más fácil de usar y, lo más importante, soportaba renderizado en modo inmediato. Además, PHIGS, aparte de su mayor dificultad, fue considerada inferior a IRIS GL respecto a funcionalidad y capacidad.La competencia de SGI (Sun Microsystems, Hewlett-Packard e IBM, entre otros) fue capaz de introducir en el mercado hardware 3D compatible con el estándar PHIGS mediante extensiones. Esto fue reduciendo la cuota de mercado de SGI conforme iban entrando diferentes proveedores en el mercado. Por todo ello, en un intento de fortalecer su influencia en el mercado, SGI decidió convertir el estándar IRIS GL en un estándar abierto.SGI observó que la API IRIS GL no podía ser abierta debido a conflictos de licencias y patentes; también contenía funciones no relevantes para los gráficos 3D como APIs para ventanas, teclado o ratón (en parte, porque fue desarrollada antes de la aparición del X Window System o de los sistemas NeWS de Sun). Además, mientras iba madurando el soporte del mercado para el nuevo estándar, se pretendía mantener los antiguos clientes mediante bibliotecas añadidas como Iris Inventor o Iris Performer.El resultado de todo lo anterior fue el lanzamiento del estándar OpenGL.Algunos de los logros que se consiguieron fueron:Estandarizar el acceso al hardware.Trasladar a los fabricantes la responsabilidad del desarrollo de las interfaces con el hardware.Delegar las funciones para ventanas al sistema operativo.Con la variedad de hardware gráfico existente, lograr que todos hablasen el mismo lenguaje obtuvo un efecto importante, ofreciendo a los desarrolladores de software una plataforma de alto nivel sobre la que trabajar.En 1992, SGI lideró la creación del OpenGL Architecture Review Board (OpenGL ARB), grupo de empresas que mantendría y extendería la especificación OpenGL en los años siguientes. OpenGL evolucionó desde IRIS GL, superando su problema de dependencia del hardware al ofrecer emulación software para aquellas características no soportadas por el hardware del que se dispusiese. Así, las aplicaciones podían utilizar gráficos avanzados en sistemas relativamente poco potentes.En 1994 SGI barajó la posibilidad de lanzar un producto denominado OpenGL++, el cual incluía elementos como una API de scene-graph (basada presumiblemente en la tecnología de Performer). Dicha especificación fue divulgada entre unos pocos grupos interesados, pero nunca apareció finalmente como producto.En 1995 Microsoft lanzó Direct3D, que se convertiría en el principal competidor de OpenGL. El 17 de diciembre de 1997 Microsoft y SGI iniciaron el proyecto Fahrenheit, esfuerzo cooperativo con el objetivo de unificar las interfaces de OpenGL y Direct3D (y añadir también una API scene-graph). En 1998 se uniría al proyecto Hewlett-Packard. Pese a tener un principio prometedor en estandarizar las APIs de gráficos 3D, debido a restricciones financieras en SGI y la falta general de apoyo por parte de la industria, fue finalmente abandonado en 1999.VersionesOpenGL 2.1El 2 de agosto de 2006 se publicó OpenGL 2.1. Siendo completamente compatible con las versiones anteriores, aporta además nuevas características como:Revisión 1.20 del OpenGL Shading Language (GLSL).Comandos que soportan la especificación de matrices no cuadradas.Objetos Pixel buffer para acelerar el tráfico de imágenes en los buffers en comandos como glTexImage2D y glReadPixels.Esta funcionalidad corresponde a la extensión ARB_pixel_buffer_object.Texturas sRGB.Esta funcionalidad corresponde a la extensión GL_EXT_texture_sRGB.OpenGL 3.0La versión más reciente de OpenGL es la 3.0http://www.opengl.org/registry/doc/glspec30.20080811.pdf, publicada el 11 de agosto de 2008. Es compatible hacia atrás con todas las versiones anteriores de OpenGL, aunque introduce un nuevo mecanismo para despreciar (deprecate en inglés) funcionalidad obsoleta y así poder simplificar la API en versiones futuras.Las principales novedades son:OpenGL Shading Language versión 1.30 (GLSL)Vertex Array Objects.Framebuffer Objects más flexibles.Texturas y render buffers en coma flotante de 32-bits.Soporte para formato en coma flotante de 16-bits para vértices y píxeles.Capacidad de almacenar vértices en un buffer tras haber sido transformados.Texture arraysZ-buffer en coma flotante de 32-bits.Sólo el hardware a nivel de DirectX 10 es capaz de ejecutar OpenGL 3.0.DocumentaciónLa popularidad de OpenGL se debe en parte a su detallada documentación oficial. El OpenGL ARB ha publicado una serie de manuales actualizados conforme la API iba evolucionando. Son fácilmente reconocibles (y conocidos) por el color de sus tapas:El Libro Rojo - The Red Book: The OpenGL Programmer's guide. ISBN 0-321-33573-2Libro de referencia y tutorial. Considerado libro de cabecera para programadores de OpenGL.El Libro Azul - The Blue Book: The OpenGL Reference manual. ISBN 0-321-17383-XEn esencia, una copia de la páginas del man de OpenGL.Incluye un poster desplegable con el diagrama de la estructura de una implementación ideal de OpenGL.El Libro Verde - The Green Book: Programming OpenGL for the X Window System. ISBN 0-201-48359-9Libro sobre el interfaz X11 y GLUT.El Libro ''Alpha'' (de tapa blanca) - The Alpha Book: OpenGL Programming for Windows 95 and Windows NT. ISBN 0-201-40709-4Libro sobre el interfaz de OpenGL en plataformas de Microsoft Windows.Para OpenGL 2.0 y posteriores:El Libro Naranja - The Orange Book: The OpenGL Shading Language. ISBN 0-321-33489-2Libro de referencia y tutorial para GLSL.ExtensionesEl estándar OpenGL permite a los fabricantes añadir nuevas funcionalidades adicionales mediante extensiones conforme aparecen nuevas tecnologías. Dichas extensiones pueden introducir nuevas funciones y constantes, y suavizar o incluso eliminar restricciones en funciones ya existentes. Cada fabricante dispone de una abreviatura que le identifica en el nombre de sus nuevas funciones o constantes. Por ejemplo, la abreviatura de NVIDIA (NV) aparece en la definición de su función glCombinerParameterfvNV() y su constante GL_NORMAL_MAP_NV.Es posible que varios fabricantes se pongan de acuerdo en implementar la misma funcionalidad extendida. En ese caso, se usa la abreviatura EXT. Incluso puede ocurrir que el ARB adopte la extensión, convirtiéndose así en estándar y utilizando la abreviatura ARB en sus nombres. La primera extensión ARB fue GL_ARB_multitexture, presentada en la versión 1.2.1. Siguiendo el camino marcado por la extensión, el multitexturing no es ya una extensión opcional, sino que entró a formar parte del núcleo de OpenGL desde la versión 1.3.Antes de usar una extensión, los programas deben comprobar su disponibilidad y, después, acceder a las nuevas funcionalidades ofrecidas. Este proceso es dependiente de la plataforma, pero bibliotecas como GLEW y GLEE lo simplifican.Las especificaciones para la mayor parte de las extensiones pueden encontrarse en el registro oficial de extensiones http://oss.sgi.com/projects/ogl-sample/registry/.Bibliotecas de utilidadesSe han programado varias bibliotecas externas que añaden características no disponibles en el propio OpenGL. Algunas de ellas son:GLU: Ofrece funciones de dibujo de alto nivel basadas en primitivas de OpenGL. Las funciones de GLU se reconocen fácilmente pues todas empiezan con el prefijo glu.GLUT: API multiplataforma que facilita una rudimentaria funcionalidad para el manejo de ventanas e interacción por medio de teclado y ratón.GLUI: Interfaz de usuario basada en GLUT; proporciona elementos de control tales como botones, cajas de selección y spinners. Es independiente del sistema operativo, sustentándose en GLUT para manejar los elementos dependientes del sistema.Referencias para lenguajes de programación (''bindings'')Para enfatizar las características multilenguaje y multiplataforma de OpenGL, se han desarrollado varios bindings en muchos lenguajes. Algunos de los lenguajes para los que están disponibles dichos bindings son:Ada: Ada OpenGL 1.1 soporta GL, GLU y GLUT http://web.archive.org/web/20041013020717/http://www.cs.chalmers.se/~bond/OPENGL/ADA/.C#: Tao es un framework para .NET que incluye OpenGL entre otras bibliotecas multimedia http://www.taoframework.com/.D: véase http://dsource.org/projects/bindings y http://dsource.org/projects/derelict.Delphi: Dot http://www.delphi3d.net/dot/.Fortran: f90gl soporta OpenGL 1.2, GLU 1.2, GLUT 3.7 http://math.nist.gov/f90gl/.Gambas: http://new.gambasdoc.org/help/comp/gb.opengl?esJava: JOGL https://jogl.dev.java.net/ y LWJGL http://lwjgl.org/ entre otros; véase http://www.opengl.org/resources/java/.Lisp: véase http://www.agentsheets.com/lisp/OpenGL.html.Perl: véase http://www.opengl.org/resources/java/.Pike: tiene un interfaz nativo a OpenGL. Además, soporta GLU y GLUT. http://pike.ida.liu.se/about/pike/modules.xml.Python: PyOpenGL soporta GL, GLU y GLUT http://pyopengl.sourceforge.net/.Visual Basic: véase http://www.opengl.org/resources/java/.Haskell: HOpenGL, soporta GL, GLU y GLUT. Véase http://haskell.org/HOpenGL/index.html.Miembros del Grupo KhronosEn 2008, algunos de los miembros del Grupo Khronos son:AMDAppleBlizzardIntel Graphics ControllersnVIDIAPara una lista completa y actualizada de los miembros del proyecto, véanse las listas de miembros promotores, contribuyentes y académicos del Grupo Khronos.Véase tambiénGLSL - Lenguaje de alto nivel de shaders para OpenGLJOGL (Java OpenGL) - Biblioteca para usar OpenGL en JavaOpenGL ES - Biblioteca para sistemas integradosBibliotecas adicionales para OpenGLGLU - Funciones adicionales (NURBS, esferas, discos, etc)GLUT - API para facilitar desarrollo con OpenGL y gestionar ventanas y eventosGLUI - Biblioteca de interfaz basada en GLUTOtras APIs de gráficosMesa 3D - Implementación de código abierto de OpenGLLWJGL (Lightweight Java Game Library) - Acceso a OpenGL, OpenAL y varios dispositivos de entradaVirtualGL - Comandos 3D entre servidor dedicado y clienteReferenciasEnlaces externosPágina oficial de OpenGLPágina de SGI sobre OpenGLOpenGL en el Open Directory ProjectGrupo KhronosNeHe Tutorials, tutoriales para el aprendizaje de OpenGLProyecto Fahrenheit en MicrosoftBlack ByteTutoriales en Español de OpenGLCategoría:Bibliotecas gráficas Categoría:Aplicaciones gráficas Categoría:Gráficos de computador en 3D Categoría:Acrónimos de informáticaar:مكتبة الرسوميات المفتوحة bg:OpenGL bn:ওপেনজিএল bs:OpenGL ca:OpenGL cs:OpenGL da:OpenGL de:OpenGL en:OpenGL fa:اپن‌جی‌ال fi:OpenGL fr:OpenGL gl:OpenGL he:OpenGL hu:OpenGL it:OpenGL ja:OpenGL ka:OpenGL ko:OpenGL lv:OpenGL nl:OpenGL no:OpenGL pl:OpenGL pt:OpenGL ro:OpenGL ru:OpenGL simple:OpenGL sk:OpenGL sl:OpenGL sr:OpenGL sv:OpenGL th:โอเพนจีแอล tr:OpenGL uk:OpenGL vi:OpenGL zh:OpenGL